{"ast":null,"code":"import { makeAutoObservable, runInAction } from 'mobx';\nimport http from '../api/http';\nimport { DEFAULT_AVATAR } from 'constants/ui';\nexport class PostsStore {\n  constructor(auth) {\n    this.auth = void 0;\n    this.posts = [];\n    this.commentsByPost = {};\n    this.previewCommentsByPost = {};\n    this.commentsCountByPost = {};\n    this.isLoadingPosts = false;\n    this.errorPosts = null;\n    this.processingPosts = new Set();\n    this.processingComments = new Set();\n    makeAutoObservable(this);\n    this.auth = auth;\n  }\n  isPostProcessing(id) {\n    return this.processingPosts.has(id);\n  }\n  isCommentProcessing(id) {\n    return this.processingComments.has(id);\n  }\n  setPostProcessing(id, on) {\n    on ? this.processingPosts.add(id) : this.processingPosts.delete(id);\n  }\n  setCommentProcessing(id, on) {\n    on ? this.processingComments.add(id) : this.processingComments.delete(id);\n  }\n  comments(postId) {\n    var _this$commentsByPost$;\n    return (_this$commentsByPost$ = this.commentsByPost[postId]) !== null && _this$commentsByPost$ !== void 0 ? _this$commentsByPost$ : [];\n  }\n  commentsPreview(postId) {\n    var _this$previewComments;\n    return (_this$previewComments = this.previewCommentsByPost[postId]) !== null && _this$previewComments !== void 0 ? _this$previewComments : [];\n  }\n  commentsCount(postId) {\n    var _ref, _ref2, _this$commentsCountBy, _this$commentsByPost$2, _this$previewComments2;\n    return (_ref = (_ref2 = (_this$commentsCountBy = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy !== void 0 ? _this$commentsCountBy : (_this$commentsByPost$2 = this.commentsByPost[postId]) === null || _this$commentsByPost$2 === void 0 ? void 0 : _this$commentsByPost$2.length) !== null && _ref2 !== void 0 ? _ref2 : (_this$previewComments2 = this.previewCommentsByPost[postId]) === null || _this$previewComments2 === void 0 ? void 0 : _this$previewComments2.length) !== null && _ref !== void 0 ? _ref : 0;\n  }\n  async uploadImage(file) {\n    var _data$data;\n    const fd = new FormData();\n    fd.append('file', file);\n    const {\n      data\n    } = await http.post('/uploads', fd, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    const item = Array.isArray(data) ? data[0] : (_data$data = data === null || data === void 0 ? void 0 : data.data) !== null && _data$data !== void 0 ? _data$data : data;\n    const url = (item === null || item === void 0 ? void 0 : item.url) || (item === null || item === void 0 ? void 0 : item.path) || (item === null || item === void 0 ? void 0 : item.src);\n    if (!url) throw new Error('Сервер не вернул ссылку на файл');\n    const clean = String(url).split('?')[0].split('#')[0];\n    const name = clean.substring(clean.lastIndexOf('/') + 1);\n    return {\n      url,\n      name\n    };\n  }\n  async fetchPosts() {\n    this.isLoadingPosts = true;\n    this.errorPosts = null;\n    try {\n      const {\n        data\n      } = await http.get('/posts');\n      data.sort((a, b) => {\n        var _b$createdAt;\n        return ((_b$createdAt = b.createdAt) === null || _b$createdAt === void 0 ? void 0 : _b$createdAt.localeCompare(a.createdAt || '')) || 0;\n      });\n      runInAction(() => this.posts = data);\n    } catch (e) {\n      runInAction(() => {\n        var _e$response, _e$response$data;\n        return this.errorPosts = (e === null || e === void 0 ? void 0 : (_e$response = e.response) === null || _e$response === void 0 ? void 0 : (_e$response$data = _e$response.data) === null || _e$response$data === void 0 ? void 0 : _e$response$data.message) || 'Не удалось загрузить посты';\n      });\n    } finally {\n      runInAction(() => this.isLoadingPosts = false);\n    }\n  }\n  async createPost(input) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      description: input.description,\n      imageUrl: input.imageUrl,\n      imageName: input.imageName,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/posts', payload);\n    runInAction(() => {\n      this.posts.unshift(data);\n      this.previewCommentsByPost[data.id] = [];\n      this.commentsCountByPost[data.id] = 0;\n    });\n  }\n  async refreshCommentsPreview(postId) {\n    const {\n      data\n    } = await http.get('/comments', {\n      params: {\n        post_id: postId\n      }\n    });\n    data.sort((a, b) => {\n      var _a$createdAt;\n      return ((_a$createdAt = a.createdAt) === null || _a$createdAt === void 0 ? void 0 : _a$createdAt.localeCompare(b.createdAt || '')) || 0;\n    });\n    const first3 = data.slice(0, 3);\n    runInAction(() => {\n      this.previewCommentsByPost[postId] = first3;\n      this.commentsCountByPost[postId] = data.length;\n    });\n  }\n  async ensureCommentsPreview(postId) {\n    if (this.commentsCountByPost[postId] === undefined) {\n      try {\n        await this.refreshCommentsPreview(postId);\n      } catch {}\n    }\n  }\n  async hardDeletePost(postId) {\n    this.setPostProcessing(postId, true);\n    try {\n      // Удаляем все комментарии к посту\n      try {\n        const {\n          data\n        } = await http.get('/comments', {\n          params: {\n            post_id: postId\n          }\n        });\n        await Promise.allSettled(data.map(c => http.delete(`/comments/${c.id}`)));\n      } catch {}\n\n      // Находим пост по ID\n      const post = this.posts.find(p => p.id === postId);\n\n      // Проверяем, есть ли изображение в посте\n      if (post !== null && post !== void 0 && post.imageUrl) {\n        try {\n          // Логируем URL изображения из поста\n          console.log('URL изображения поста:', post.imageUrl);\n\n          // Отправляем запрос для получения ID изображения по URL\n          const {\n            data\n          } = await http.get('/uploads', {\n            params: {\n              url: post.imageUrl\n            } // Используем URL изображения из поста\n          });\n          console.log('Ответ от сервера:', data);\n\n          // Извлекаем ID изображения из ответа\n          const imageId = data.length > 0 ? data[0].id : undefined;\n\n          // Логируем найденный ID изображения\n          console.log('ID изображения из загрузок:', imageId);\n\n          // Если ID изображения найдено, удаляем его\n          if (imageId) {\n            await http.delete(`/uploads/${imageId}`);\n            console.log('Изображение успешно удалено');\n          } else {\n            console.error('Не удалось найти ID изображения');\n          }\n        } catch (error) {\n          console.error('Ошибка при удалении изображения поста:', error);\n        }\n      }\n\n      // Удаляем сам пост\n      await http.delete(`/posts/${postId}`);\n      console.log('Пост успешно удален');\n      runInAction(() => {\n        this.posts = this.posts.filter(p => p.id !== postId);\n        delete this.commentsByPost[postId];\n        delete this.previewCommentsByPost[postId];\n        delete this.commentsCountByPost[postId];\n      });\n    } finally {\n      this.setPostProcessing(postId, false);\n    }\n  }\n  async fetchComments(postId) {\n    const {\n      data\n    } = await http.get('/comments', {\n      params: {\n        post_id: postId\n      }\n    });\n    data.sort((a, b) => {\n      var _a$createdAt2;\n      return ((_a$createdAt2 = a.createdAt) === null || _a$createdAt2 === void 0 ? void 0 : _a$createdAt2.localeCompare(b.createdAt || '')) || 0;\n    });\n    runInAction(() => {\n      this.commentsByPost[postId] = data;\n      this.commentsCountByPost[postId] = data.length;\n      this.previewCommentsByPost[postId] = data.slice(0, 3);\n    });\n  }\n  async addComment(postId, text) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      post_id: postId,\n      text,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/comments', payload);\n    runInAction(() => {\n      var _this$commentsCountBy2;\n      if (this.commentsByPost[postId]) {\n        const list = this.commentsByPost[postId];\n        this.commentsByPost[postId] = [...list, data].sort((a, b) => {\n          var _a$createdAt3;\n          return ((_a$createdAt3 = a.createdAt) === null || _a$createdAt3 === void 0 ? void 0 : _a$createdAt3.localeCompare(b.createdAt || '')) || 0;\n        });\n      }\n      const prevCount = (_this$commentsCountBy2 = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy2 !== void 0 ? _this$commentsCountBy2 : 0;\n      const newCount = prevCount + 1;\n      this.commentsCountByPost[postId] = newCount;\n      if (prevCount < 3) {\n        var _this$previewComments3;\n        const prev = (_this$previewComments3 = this.previewCommentsByPost[postId]) !== null && _this$previewComments3 !== void 0 ? _this$previewComments3 : [];\n        const merged = [...prev, data].sort((a, b) => {\n          var _a$createdAt4;\n          return ((_a$createdAt4 = a.createdAt) === null || _a$createdAt4 === void 0 ? void 0 : _a$createdAt4.localeCompare(b.createdAt || '')) || 0;\n        });\n        this.previewCommentsByPost[postId] = merged.slice(0, 3);\n      }\n      this.posts = this.posts.map(p => p.id === postId ? {\n        ...p,\n        commentsCount: newCount\n      } : p);\n    });\n  }\n  async fetchUserAvatar(userId) {\n    try {\n      const {\n        data\n      } = await http.get(`/users/${userId}/avatar`);\n      return data.avatarUrl || DEFAULT_AVATAR;\n    } catch (e) {\n      return DEFAULT_AVATAR;\n    }\n  }\n  async hardDeleteComment(postId, commentId) {\n    this.setCommentProcessing(commentId, true);\n    try {\n      await http.delete(`/comments/${commentId}`);\n      runInAction(() => {\n        if (this.commentsByPost[postId]) {\n          this.commentsByPost[postId] = this.commentsByPost[postId].filter(c => c.id !== commentId);\n        }\n      });\n      await this.refreshCommentsPreview(postId);\n      runInAction(() => {\n        this.posts = this.posts.map(p => p.id === postId ? {\n          ...p,\n          commentsCount: this.commentsCount(postId)\n        } : p);\n      });\n    } finally {\n      this.setCommentProcessing(commentId, false);\n    }\n  }\n  async updateAllUserAvatarsOnServer(userId, newAvatarUrl) {\n    try {\n      const userPosts = this.posts.filter(p => p.authorId === userId);\n      await Promise.allSettled(userPosts.map(post => http.patch(`/posts/${post.id}`, {\n        authorAvatarUrl: newAvatarUrl\n      })));\n      const userComments = [];\n      Object.values(this.commentsByPost).forEach(comments => {\n        comments.filter(c => c.authorId === userId).forEach(c => userComments.push(c));\n      });\n      await Promise.allSettled(userComments.map(comment => http.patch(`/comments/${comment.id}`, {\n        authorAvatarUrl: newAvatarUrl\n      })));\n    } catch (error) {\n      console.error('Ошибка при массовом обновлении аватаров на сервере:', error);\n    }\n  }\n  async updateAvatarInPostsAndComments(userId, newAvatarUrl) {\n    try {\n      this.posts.forEach(post => {\n        if (post.authorId === userId) {\n          post.authorAvatarUrl = newAvatarUrl;\n        }\n      });\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n      this.posts = [...this.posts];\n    } catch (error) {\n      console.error('Ошибка при обновлении аватарок в постах и комментариях:', error);\n    }\n  }\n  async updateAvatarOnServer(userId, newAvatarUrl) {\n    try {\n      const payload = {\n        avatarUrl: newAvatarUrl\n      };\n      const response = await http.patch(`/users/${userId}`, payload);\n      if (response.status === 200) {\n        await this.updateAllUserAvatarsOnServer(userId, newAvatarUrl);\n        await this.updateAvatarInPostsAndComments(userId, newAvatarUrl);\n      } else {\n        throw new Error('Ошибка при обновлении аватарки на сервере');\n      }\n    } catch (error) {\n      console.error('Ошибка при обновлении аватарки на сервере:', error);\n    }\n  }\n  async refreshAvatarInCache(userId, newAvatarUrl) {\n    runInAction(() => {\n      this.posts.forEach(post => {\n        if (post.authorId === userId && post.authorAvatarUrl !== newAvatarUrl) {\n          post.authorAvatarUrl = newAvatarUrl;\n        }\n      });\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\n        this.commentsByPost[Number(postId)] = comments.map(comment => comment.authorId === userId && comment.authorAvatarUrl !== newAvatarUrl ? {\n          ...comment,\n          authorAvatarUrl: newAvatarUrl\n        } : comment);\n      });\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => comment.authorId === userId && comment.authorAvatarUrl !== newAvatarUrl ? {\n          ...comment,\n          authorAvatarUrl: newAvatarUrl\n        } : comment);\n      });\n      this.posts = [...this.posts];\n    });\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","http","DEFAULT_AVATAR","PostsStore","constructor","auth","posts","commentsByPost","previewCommentsByPost","commentsCountByPost","isLoadingPosts","errorPosts","processingPosts","Set","processingComments","isPostProcessing","id","has","isCommentProcessing","setPostProcessing","on","add","delete","setCommentProcessing","comments","postId","_this$commentsByPost$","commentsPreview","_this$previewComments","commentsCount","_ref","_ref2","_this$commentsCountBy","_this$commentsByPost$2","_this$previewComments2","length","uploadImage","file","_data$data","fd","FormData","append","data","post","headers","item","Array","isArray","url","path","src","Error","clean","String","split","name","substring","lastIndexOf","fetchPosts","get","sort","a","b","_b$createdAt","createdAt","localeCompare","e","_e$response","_e$response$data","response","message","createPost","input","user","payload","description","imageUrl","imageName","authorId","authorName","authorAvatarUrl","avatarUrl","Date","toISOString","unshift","refreshCommentsPreview","params","post_id","_a$createdAt","first3","slice","ensureCommentsPreview","undefined","hardDeletePost","Promise","allSettled","map","c","find","p","console","log","imageId","error","filter","fetchComments","_a$createdAt2","addComment","text","_this$commentsCountBy2","list","_a$createdAt3","prevCount","newCount","_this$previewComments3","prev","merged","_a$createdAt4","fetchUserAvatar","userId","hardDeleteComment","commentId","updateAllUserAvatarsOnServer","newAvatarUrl","userPosts","patch","userComments","Object","values","forEach","push","comment","updateAvatarInPostsAndComments","entries","Number","updateAvatarOnServer","status","refreshAvatarInCache"],"sources":["C:/praka/www/media/src/stores/posts.store.ts"],"sourcesContent":["import { makeAutoObservable, runInAction } from 'mobx'\r\nimport http from '../api/http'\r\nimport type { ID, Post, Comment, CreatePostDTO } from '../types'\r\nimport type { AuthStore } from './auth.store'\r\nimport { DEFAULT_AVATAR } from 'constants/ui'\r\n\r\nexport class PostsStore {\r\n  private auth: AuthStore\r\n\r\n  posts: Post[] = []\r\n  commentsByPost: Record<ID, Comment[]> = {}\r\n  previewCommentsByPost: Record<ID, Comment[]> = {}\r\n  commentsCountByPost: Record<ID, number> = {}\r\n\r\n  isLoadingPosts = false\r\n  errorPosts: string | null = null\r\n\r\n  private processingPosts = new Set<ID>()\r\n  private processingComments = new Set<ID>()\r\n\r\n  constructor(auth: AuthStore) {\r\n    makeAutoObservable(this)\r\n    this.auth = auth\r\n  }\r\n\r\n  isPostProcessing(id: ID) { return this.processingPosts.has(id) }\r\n  isCommentProcessing(id: ID) { return this.processingComments.has(id) }\r\n  private setPostProcessing(id: ID, on: boolean) { on ? this.processingPosts.add(id) : this.processingPosts.delete(id) }\r\n  private setCommentProcessing(id: ID, on: boolean) { on ? this.processingComments.add(id) : this.processingComments.delete(id) }\r\n\r\n  comments(postId: ID) { return this.commentsByPost[postId] ?? [] }\r\n  commentsPreview(postId: ID) { return this.previewCommentsByPost[postId] ?? [] }\r\n  commentsCount(postId: ID) {\r\n    return this.commentsCountByPost[postId]\r\n      ?? this.commentsByPost[postId]?.length\r\n      ?? this.previewCommentsByPost[postId]?.length\r\n      ?? 0\r\n  }\r\n\r\n  async uploadImage(file: File): Promise<{ url: string; name: string }> {\r\n    const fd = new FormData()\r\n    fd.append('file', file)\r\n\r\n    const { data } = await http.post<any>('/uploads', fd, {\r\n      headers: { 'Content-Type': 'multipart/form-data' },\r\n    })\r\n\r\n    const item = Array.isArray(data) ? data[0] : (data?.data ?? data)\r\n    const url: string = item?.url || item?.path || item?.src\r\n    if (!url) throw new Error('Сервер не вернул ссылку на файл')\r\n\r\n    const clean = String(url).split('?')[0].split('#')[0]\r\n    const name = clean.substring(clean.lastIndexOf('/') + 1)\r\n\r\n    return { url, name }\r\n  }\r\n\r\n  async fetchPosts() {\r\n    this.isLoadingPosts = true\r\n    this.errorPosts = null\r\n    try {\r\n      const { data } = await http.get<Post[]>('/posts')\r\n      data.sort((a, b) => (b.createdAt?.localeCompare(a.createdAt || '') || 0))\r\n      runInAction(() => (this.posts = data))\r\n\r\n    } catch (e: any) {\r\n      runInAction(() => (this.errorPosts = e?.response?.data?.message || 'Не удалось загрузить посты'))\r\n    } finally {\r\n      runInAction(() => (this.isLoadingPosts = false))\r\n    }\r\n  }\r\n\r\n  async createPost(input: CreatePostDTO) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      description: input.description,\r\n      imageUrl: input.imageUrl,\r\n      imageName: input.imageName,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl,\r\n      createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Post>('/posts', payload)\r\n    runInAction(() => {\r\n      this.posts.unshift(data)\r\n\r\n      this.previewCommentsByPost[data.id] = []\r\n      this.commentsCountByPost[data.id] = 0\r\n    })\r\n  }\r\n\r\n  async refreshCommentsPreview(postId: ID) {\r\n    const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n    data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n    const first3 = data.slice(0, 3)\r\n    runInAction(() => {\r\n      this.previewCommentsByPost[postId] = first3\r\n      this.commentsCountByPost[postId] = data.length\r\n    })\r\n  }\r\n\r\n  async ensureCommentsPreview(postId: ID) {\r\n    if (this.commentsCountByPost[postId] === undefined) {\r\n      try { await this.refreshCommentsPreview(postId) } catch {}\r\n    }\r\n  }\r\n\r\n  async hardDeletePost(postId: ID) {\r\n    this.setPostProcessing(postId, true);\r\n    try {\r\n      // Удаляем все комментарии к посту\r\n      try {\r\n        const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } });\r\n        await Promise.allSettled(data.map(c => http.delete(`/comments/${c.id}`)));\r\n      } catch {}\r\n\r\n      // Находим пост по ID\r\n      const post = this.posts.find(p => p.id === postId);\r\n\r\n      // Проверяем, есть ли изображение в посте\r\n      if (post?.imageUrl) {\r\n        try {\r\n          // Логируем URL изображения из поста\r\n          console.log('URL изображения поста:', post.imageUrl);\r\n\r\n          // Отправляем запрос для получения ID изображения по URL\r\n          const { data } = await http.get<any[]>('/uploads', {\r\n            params: { url: post.imageUrl }  // Используем URL изображения из поста\r\n          });\r\n\r\n          console.log('Ответ от сервера:', data);\r\n\r\n          // Извлекаем ID изображения из ответа\r\n          const imageId = data.length > 0 ? data[0].id : undefined;\r\n\r\n          // Логируем найденный ID изображения\r\n          console.log('ID изображения из загрузок:', imageId);\r\n\r\n          // Если ID изображения найдено, удаляем его\r\n          if (imageId) {\r\n            await http.delete(`/uploads/${imageId}`);\r\n            console.log('Изображение успешно удалено');\r\n          } else {\r\n            console.error('Не удалось найти ID изображения');\r\n          }\r\n        } catch (error) {\r\n          console.error('Ошибка при удалении изображения поста:', error);\r\n        }\r\n      }\r\n\r\n      // Удаляем сам пост\r\n      await http.delete<void>(`/posts/${postId}`);\r\n      console.log('Пост успешно удален');\r\n\r\n      runInAction(() => {\r\n        this.posts = this.posts.filter(p => p.id !== postId);\r\n        delete this.commentsByPost[postId];\r\n        delete this.previewCommentsByPost[postId];\r\n        delete this.commentsCountByPost[postId];\r\n      });\r\n    } finally {\r\n      this.setPostProcessing(postId, false);\r\n    }\r\n  }\r\n\r\n  async fetchComments(postId: ID) {\r\n    const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n    data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n    runInAction(() => {\r\n      this.commentsByPost[postId] = data\r\n      this.commentsCountByPost[postId] = data.length\r\n      this.previewCommentsByPost[postId] = data.slice(0, 3) \r\n    })\r\n  }\r\n\r\n  async addComment(postId: ID, text: string) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      post_id: postId,\r\n      text,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl,\r\n      createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Comment>('/comments', payload)\r\n    runInAction(() => {\r\n      if (this.commentsByPost[postId]) {\r\n        const list = this.commentsByPost[postId]\r\n        this.commentsByPost[postId] = [...list, data].sort((a, b) =>\r\n          (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n      }\r\n\r\n      const prevCount = this.commentsCountByPost[postId] ?? 0\r\n      const newCount = prevCount + 1\r\n      this.commentsCountByPost[postId] = newCount\r\n\r\n      if (prevCount < 3) {\r\n        const prev = this.previewCommentsByPost[postId] ?? []\r\n        const merged = [...prev, data].sort((a, b) =>\r\n          (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n        this.previewCommentsByPost[postId] = merged.slice(0, 3)\r\n      }\r\n\r\n      this.posts = this.posts.map(p =>\r\n        p.id === postId ? { ...p, commentsCount: newCount } : p\r\n      )\r\n    })\r\n  }\r\n\r\n  async fetchUserAvatar(userId: ID): Promise<string> {\r\n    try {\r\n      const { data } = await http.get<{ avatarUrl: string }>(`/users/${userId}/avatar`)\r\n      return data.avatarUrl || DEFAULT_AVATAR\r\n    } catch (e) {\r\n      return DEFAULT_AVATAR\r\n    }\r\n  }\r\n\r\n  async hardDeleteComment(postId: ID, commentId: ID) {\r\n    this.setCommentProcessing(commentId, true)\r\n    try {\r\n      await http.delete<void>(`/comments/${commentId}`)\r\n      runInAction(() => {\r\n        if (this.commentsByPost[postId]) {\r\n          this.commentsByPost[postId] =\r\n            this.commentsByPost[postId].filter(c => c.id !== commentId)\r\n        }\r\n      })\r\n      await this.refreshCommentsPreview(postId)\r\n      runInAction(() => {\r\n        this.posts = this.posts.map(p =>\r\n          p.id === postId ? { ...p, commentsCount: this.commentsCount(postId) } : p\r\n        )\r\n      })\r\n    } finally {\r\n      this.setCommentProcessing(commentId, false)\r\n    }\r\n  }\r\n\r\n  async updateAllUserAvatarsOnServer(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      const userPosts = this.posts.filter(p => p.authorId === userId);\r\n      await Promise.allSettled(\r\n        userPosts.map(post => \r\n          http.patch(`/posts/${post.id}`, { authorAvatarUrl: newAvatarUrl })\r\n        )\r\n      );\r\n\r\n      const userComments: Comment[] = [];\r\n      Object.values(this.commentsByPost).forEach(comments => {\r\n        comments.filter(c => c.authorId === userId).forEach(c => userComments.push(c));\r\n      });\r\n      \r\n      await Promise.allSettled(\r\n        userComments.map(comment =>\r\n          http.patch(`/comments/${comment.id}`, { authorAvatarUrl: newAvatarUrl })\r\n        )\r\n      );\r\n    } catch (error) {\r\n      console.error('Ошибка при массовом обновлении аватаров на сервере:', error);\r\n    }\r\n  }\r\n\r\n  async updateAvatarInPostsAndComments(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      this.posts.forEach(post => {\r\n        if (post.authorId === userId) {\r\n          post.authorAvatarUrl = newAvatarUrl;\r\n        }\r\n      });\r\n\r\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\r\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\r\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      this.posts = [...this.posts];\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении аватарок в постах и комментариях:', error);\r\n    }\r\n  }\r\n\r\n  async updateAvatarOnServer(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      const payload = { avatarUrl: newAvatarUrl };\r\n      const response = await http.patch(`/users/${userId}`, payload);\r\n\r\n      if (response.status === 200) {\r\n        await this.updateAllUserAvatarsOnServer(userId, newAvatarUrl);\r\n        await this.updateAvatarInPostsAndComments(userId, newAvatarUrl);\r\n      } else {\r\n        throw new Error('Ошибка при обновлении аватарки на сервере');\r\n      }\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении аватарки на сервере:', error);\r\n    }\r\n  }\r\n\r\n  async refreshAvatarInCache(userId: ID, newAvatarUrl: string) {\r\n    runInAction(() => {\r\n      this.posts.forEach(post => {\r\n        if (post.authorId === userId && post.authorAvatarUrl !== newAvatarUrl) {\r\n          post.authorAvatarUrl = newAvatarUrl;\r\n        }\r\n      });\r\n\r\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\r\n        this.commentsByPost[Number(postId)] = comments.map(comment =>\r\n          comment.authorId === userId && comment.authorAvatarUrl !== newAvatarUrl\r\n            ? { ...comment, authorAvatarUrl: newAvatarUrl }\r\n            : comment\r\n        );\r\n      });\r\n\r\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\r\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment =>\r\n          comment.authorId === userId && comment.authorAvatarUrl !== newAvatarUrl\r\n            ? { ...comment, authorAvatarUrl: newAvatarUrl }\r\n            : comment\r\n        );\r\n      });\r\n\r\n      this.posts = [...this.posts];  \r\n    });\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}