{"ast":null,"code":"import { makeAutoObservable, runInAction } from 'mobx';\nimport http from '../api/http';\nimport { DEFAULT_AVATAR } from 'constants/ui';\nexport class PostsStore {\n  constructor(auth) {\n    this.auth = void 0;\n    this.posts = [];\n    this.commentsByPost = {};\n    this.previewCommentsByPost = {};\n    this.commentsCountByPost = {};\n    this.isLoadingPosts = false;\n    this.errorPosts = null;\n    this.processingPosts = new Set();\n    this.processingComments = new Set();\n    makeAutoObservable(this);\n    this.auth = auth;\n  }\n  isPostProcessing(id) {\n    return this.processingPosts.has(id);\n  }\n  isCommentProcessing(id) {\n    return this.processingComments.has(id);\n  }\n  setPostProcessing(id, on) {\n    on ? this.processingPosts.add(id) : this.processingPosts.delete(id);\n  }\n  setCommentProcessing(id, on) {\n    on ? this.processingComments.add(id) : this.processingComments.delete(id);\n  }\n  comments(postId) {\n    var _this$commentsByPost$;\n    return (_this$commentsByPost$ = this.commentsByPost[postId]) !== null && _this$commentsByPost$ !== void 0 ? _this$commentsByPost$ : [];\n  }\n  commentsPreview(postId) {\n    var _this$previewComments;\n    return (_this$previewComments = this.previewCommentsByPost[postId]) !== null && _this$previewComments !== void 0 ? _this$previewComments : [];\n  }\n  commentsCount(postId) {\n    var _ref, _ref2, _this$commentsCountBy, _this$commentsByPost$2, _this$previewComments2;\n    return (_ref = (_ref2 = (_this$commentsCountBy = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy !== void 0 ? _this$commentsCountBy : (_this$commentsByPost$2 = this.commentsByPost[postId]) === null || _this$commentsByPost$2 === void 0 ? void 0 : _this$commentsByPost$2.length) !== null && _ref2 !== void 0 ? _ref2 : (_this$previewComments2 = this.previewCommentsByPost[postId]) === null || _this$previewComments2 === void 0 ? void 0 : _this$previewComments2.length) !== null && _ref !== void 0 ? _ref : 0;\n  }\n  async uploadImage(file) {\n    var _data$data;\n    const fd = new FormData();\n    fd.append('file', file);\n    const {\n      data\n    } = await http.post('/uploads', fd, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    const item = Array.isArray(data) ? data[0] : (_data$data = data === null || data === void 0 ? void 0 : data.data) !== null && _data$data !== void 0 ? _data$data : data;\n    const url = (item === null || item === void 0 ? void 0 : item.url) || (item === null || item === void 0 ? void 0 : item.path) || (item === null || item === void 0 ? void 0 : item.src);\n    if (!url) throw new Error('Сервер не вернул ссылку на файл');\n    const clean = String(url).split('?')[0].split('#')[0];\n    const name = clean.substring(clean.lastIndexOf('/') + 1);\n    return {\n      url,\n      name\n    };\n  }\n  async fetchPosts() {\n    this.isLoadingPosts = true;\n    this.errorPosts = null;\n    try {\n      const {\n        data\n      } = await http.get('/posts');\n      data.sort((a, b) => {\n        var _b$createdAt;\n        return ((_b$createdAt = b.createdAt) === null || _b$createdAt === void 0 ? void 0 : _b$createdAt.localeCompare(a.createdAt || '')) || 0;\n      });\n      runInAction(() => this.posts = data);\n    } catch (e) {\n      runInAction(() => {\n        var _e$response, _e$response$data;\n        return this.errorPosts = (e === null || e === void 0 ? void 0 : (_e$response = e.response) === null || _e$response === void 0 ? void 0 : (_e$response$data = _e$response.data) === null || _e$response$data === void 0 ? void 0 : _e$response$data.message) || 'Не удалось загрузить посты';\n      });\n    } finally {\n      runInAction(() => this.isLoadingPosts = false);\n    }\n  }\n  async createPost(input) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      description: input.description,\n      imageUrl: input.imageUrl,\n      imageName: input.imageName,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/posts', payload);\n    runInAction(() => {\n      this.posts.unshift(data);\n      this.previewCommentsByPost[data.id] = [];\n      this.commentsCountByPost[data.id] = 0;\n    });\n  }\n  async refreshCommentsPreview(postId) {\n    const {\n      data\n    } = await http.get('/comments', {\n      params: {\n        post_id: postId\n      }\n    });\n    data.sort((a, b) => {\n      var _a$createdAt;\n      return ((_a$createdAt = a.createdAt) === null || _a$createdAt === void 0 ? void 0 : _a$createdAt.localeCompare(b.createdAt || '')) || 0;\n    });\n    const first3 = data.slice(0, 3);\n    runInAction(() => {\n      this.previewCommentsByPost[postId] = first3;\n      this.commentsCountByPost[postId] = data.length;\n    });\n  }\n  async ensureCommentsPreview(postId) {\n    if (this.commentsCountByPost[postId] === undefined) {\n      try {\n        await this.refreshCommentsPreview(postId);\n      } catch {}\n    }\n  }\n  async hardDeletePost(postId) {\n    this.setPostProcessing(postId, true);\n    try {\n      try {\n        const {\n          data\n        } = await http.get('/comments', {\n          params: {\n            post_id: postId\n          }\n        });\n        await Promise.allSettled(data.map(c => http.delete(`/comments/${c.id}`)));\n      } catch {}\n      const post = this.posts.find(p => p.id === postId);\n      if (post !== null && post !== void 0 && post.imageName) {\n        try {\n          await http.delete(`/uploads/${encodeURIComponent(post.imageName)}`);\n        } catch {}\n      }\n      await http.delete(`/posts/${postId}`);\n      runInAction(() => {\n        this.posts = this.posts.filter(p => p.id !== postId);\n        delete this.commentsByPost[postId];\n        delete this.previewCommentsByPost[postId];\n        delete this.commentsCountByPost[postId];\n      });\n    } finally {\n      this.setPostProcessing(postId, false);\n    }\n  }\n  async fetchComments(postId) {\n    const {\n      data\n    } = await http.get('/comments', {\n      params: {\n        post_id: postId\n      }\n    });\n    data.sort((a, b) => {\n      var _a$createdAt2;\n      return ((_a$createdAt2 = a.createdAt) === null || _a$createdAt2 === void 0 ? void 0 : _a$createdAt2.localeCompare(b.createdAt || '')) || 0;\n    });\n    runInAction(() => {\n      this.commentsByPost[postId] = data;\n      this.commentsCountByPost[postId] = data.length;\n      this.previewCommentsByPost[postId] = data.slice(0, 3);\n    });\n  }\n  async addComment(postId, text) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      post_id: postId,\n      text,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/comments', payload);\n    runInAction(() => {\n      var _this$commentsCountBy2;\n      if (this.commentsByPost[postId]) {\n        const list = this.commentsByPost[postId];\n        this.commentsByPost[postId] = [...list, data].sort((a, b) => {\n          var _a$createdAt3;\n          return ((_a$createdAt3 = a.createdAt) === null || _a$createdAt3 === void 0 ? void 0 : _a$createdAt3.localeCompare(b.createdAt || '')) || 0;\n        });\n      }\n      const prevCount = (_this$commentsCountBy2 = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy2 !== void 0 ? _this$commentsCountBy2 : 0;\n      const newCount = prevCount + 1;\n      this.commentsCountByPost[postId] = newCount;\n      if (prevCount < 3) {\n        var _this$previewComments3;\n        const prev = (_this$previewComments3 = this.previewCommentsByPost[postId]) !== null && _this$previewComments3 !== void 0 ? _this$previewComments3 : [];\n        const merged = [...prev, data].sort((a, b) => {\n          var _a$createdAt4;\n          return ((_a$createdAt4 = a.createdAt) === null || _a$createdAt4 === void 0 ? void 0 : _a$createdAt4.localeCompare(b.createdAt || '')) || 0;\n        });\n        this.previewCommentsByPost[postId] = merged.slice(0, 3);\n      }\n      this.posts = this.posts.map(p => p.id === postId ? {\n        ...p,\n        commentsCount: newCount\n      } : p);\n    });\n  }\n  async fetchUserAvatar(userId) {\n    try {\n      const {\n        data\n      } = await http.get(`/users/${userId}/avatar`);\n      return data.avatarUrl || DEFAULT_AVATAR;\n    } catch (e) {\n      return DEFAULT_AVATAR;\n    }\n  }\n  async hardDeleteComment(postId, commentId) {\n    this.setCommentProcessing(commentId, true);\n    try {\n      await http.delete(`/comments/${commentId}`);\n      runInAction(() => {\n        if (this.commentsByPost[postId]) {\n          this.commentsByPost[postId] = this.commentsByPost[postId].filter(c => c.id !== commentId);\n        }\n      });\n      await this.refreshCommentsPreview(postId);\n      runInAction(() => {\n        this.posts = this.posts.map(p => p.id === postId ? {\n          ...p,\n          commentsCount: this.commentsCount(postId)\n        } : p);\n      });\n    } finally {\n      this.setCommentProcessing(commentId, false);\n    }\n  }\n  async updateAllUserAvatarsOnServer(userId, newAvatarUrl) {\n    try {\n      const userPosts = this.posts.filter(p => p.authorId === userId);\n      await Promise.allSettled(userPosts.map(post => http.patch(`/posts/${post.id}`, {\n        authorAvatarUrl: newAvatarUrl\n      })));\n      const userComments = [];\n      Object.values(this.commentsByPost).forEach(comments => {\n        comments.filter(c => c.authorId === userId).forEach(c => userComments.push(c));\n      });\n      await Promise.allSettled(userComments.map(comment => http.patch(`/comments/${comment.id}`, {\n        authorAvatarUrl: newAvatarUrl\n      })));\n    } catch (error) {\n      console.error('Ошибка при массовом обновлении аватаров на сервере:', error);\n    }\n  }\n  async updateAvatarInPostsAndComments(userId, newAvatarUrl) {\n    try {\n      this.posts.forEach(post => {\n        if (post.authorId === userId) {\n          post.authorAvatarUrl = newAvatarUrl;\n        }\n      });\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n      this.posts = [...this.posts];\n    } catch (error) {\n      console.error('Ошибка при обновлении аватарок в постах и комментариях:', error);\n    }\n  }\n  async updateAvatarOnServer(userId, newAvatarUrl) {\n    try {\n      const payload = {\n        avatarUrl: newAvatarUrl\n      };\n      const response = await http.patch(`/users/${userId}`, payload);\n      if (response.status === 200) {\n        await this.updateAllUserAvatarsOnServer(userId, newAvatarUrl);\n        await this.updateAvatarInPostsAndComments(userId, newAvatarUrl);\n      } else {\n        throw new Error('Ошибка при обновлении аватарки на сервере');\n      }\n    } catch (error) {\n      console.error('Ошибка при обновлении аватарки на сервере:', error);\n    }\n  }\n  async refreshAvatarInCache(userId, newAvatarUrl) {\n    runInAction(() => {\n      var _this$posts$find;\n      const currentAvatar = (_this$posts$find = this.posts.find(p => p.authorId === userId)) === null || _this$posts$find === void 0 ? void 0 : _this$posts$find.authorAvatarUrl;\n      if (currentAvatar === newAvatarUrl) return;\n      this.posts.forEach(post => {\n        if (post.authorId === userId) {\n          post.authorAvatarUrl = newAvatarUrl;\n        }\n      });\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n      this.posts = [...this.posts];\n    });\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","http","DEFAULT_AVATAR","PostsStore","constructor","auth","posts","commentsByPost","previewCommentsByPost","commentsCountByPost","isLoadingPosts","errorPosts","processingPosts","Set","processingComments","isPostProcessing","id","has","isCommentProcessing","setPostProcessing","on","add","delete","setCommentProcessing","comments","postId","_this$commentsByPost$","commentsPreview","_this$previewComments","commentsCount","_ref","_ref2","_this$commentsCountBy","_this$commentsByPost$2","_this$previewComments2","length","uploadImage","file","_data$data","fd","FormData","append","data","post","headers","item","Array","isArray","url","path","src","Error","clean","String","split","name","substring","lastIndexOf","fetchPosts","get","sort","a","b","_b$createdAt","createdAt","localeCompare","e","_e$response","_e$response$data","response","message","createPost","input","user","payload","description","imageUrl","imageName","authorId","authorName","authorAvatarUrl","avatarUrl","Date","toISOString","unshift","refreshCommentsPreview","params","post_id","_a$createdAt","first3","slice","ensureCommentsPreview","undefined","hardDeletePost","Promise","allSettled","map","c","find","p","encodeURIComponent","filter","fetchComments","_a$createdAt2","addComment","text","_this$commentsCountBy2","list","_a$createdAt3","prevCount","newCount","_this$previewComments3","prev","merged","_a$createdAt4","fetchUserAvatar","userId","hardDeleteComment","commentId","updateAllUserAvatarsOnServer","newAvatarUrl","userPosts","patch","userComments","Object","values","forEach","push","comment","error","console","updateAvatarInPostsAndComments","entries","Number","updateAvatarOnServer","status","refreshAvatarInCache","_this$posts$find","currentAvatar"],"sources":["C:/praka/www/media/src/stores/posts.store.ts"],"sourcesContent":["import { makeAutoObservable, runInAction } from 'mobx'\r\nimport http from '../api/http'\r\nimport type { ID, Post, Comment, CreatePostDTO } from '../types'\r\nimport type { AuthStore } from './auth.store'\r\nimport { DEFAULT_AVATAR } from 'constants/ui'\r\n\r\nexport class PostsStore {\r\n  private auth: AuthStore\r\n\r\n  posts: Post[] = []\r\n  commentsByPost: Record<ID, Comment[]> = {}\r\n  previewCommentsByPost: Record<ID, Comment[]> = {}\r\n  commentsCountByPost: Record<ID, number> = {}\r\n\r\n  isLoadingPosts = false\r\n  errorPosts: string | null = null\r\n\r\n  private processingPosts = new Set<ID>()\r\n  private processingComments = new Set<ID>()\r\n\r\n  constructor(auth: AuthStore) {\r\n    makeAutoObservable(this)\r\n    this.auth = auth\r\n  }\r\n\r\n  isPostProcessing(id: ID) { return this.processingPosts.has(id) }\r\n  isCommentProcessing(id: ID) { return this.processingComments.has(id) }\r\n  private setPostProcessing(id: ID, on: boolean) { on ? this.processingPosts.add(id) : this.processingPosts.delete(id) }\r\n  private setCommentProcessing(id: ID, on: boolean) { on ? this.processingComments.add(id) : this.processingComments.delete(id) }\r\n\r\n  comments(postId: ID) { return this.commentsByPost[postId] ?? [] }\r\n  commentsPreview(postId: ID) { return this.previewCommentsByPost[postId] ?? [] }\r\n  commentsCount(postId: ID) {\r\n    return this.commentsCountByPost[postId]\r\n      ?? this.commentsByPost[postId]?.length\r\n      ?? this.previewCommentsByPost[postId]?.length\r\n      ?? 0\r\n  }\r\n\r\n  async uploadImage(file: File): Promise<{ url: string; name: string }> {\r\n    const fd = new FormData()\r\n    fd.append('file', file)\r\n\r\n    const { data } = await http.post<any>('/uploads', fd, {\r\n      headers: { 'Content-Type': 'multipart/form-data' },\r\n    })\r\n\r\n    const item = Array.isArray(data) ? data[0] : (data?.data ?? data)\r\n    const url: string = item?.url || item?.path || item?.src\r\n    if (!url) throw new Error('Сервер не вернул ссылку на файл')\r\n\r\n    const clean = String(url).split('?')[0].split('#')[0]\r\n    const name = clean.substring(clean.lastIndexOf('/') + 1)\r\n\r\n    return { url, name }\r\n  }\r\n\r\n  async fetchPosts() {\r\n    this.isLoadingPosts = true\r\n    this.errorPosts = null\r\n    try {\r\n      const { data } = await http.get<Post[]>('/posts')\r\n      data.sort((a, b) => (b.createdAt?.localeCompare(a.createdAt || '') || 0))\r\n      runInAction(() => (this.posts = data))\r\n\r\n    } catch (e: any) {\r\n      runInAction(() => (this.errorPosts = e?.response?.data?.message || 'Не удалось загрузить посты'))\r\n    } finally {\r\n      runInAction(() => (this.isLoadingPosts = false))\r\n    }\r\n  }\r\n\r\n  async createPost(input: CreatePostDTO) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      description: input.description,\r\n      imageUrl: input.imageUrl,\r\n      imageName: input.imageName,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl,\r\n      createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Post>('/posts', payload)\r\n    runInAction(() => {\r\n      this.posts.unshift(data)\r\n\r\n      this.previewCommentsByPost[data.id] = []\r\n      this.commentsCountByPost[data.id] = 0\r\n    })\r\n  }\r\n\r\n  async refreshCommentsPreview(postId: ID) {\r\n    const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n    data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n    const first3 = data.slice(0, 3)\r\n    runInAction(() => {\r\n      this.previewCommentsByPost[postId] = first3\r\n      this.commentsCountByPost[postId] = data.length\r\n    })\r\n  }\r\n\r\n  async ensureCommentsPreview(postId: ID) {\r\n    if (this.commentsCountByPost[postId] === undefined) {\r\n      try { await this.refreshCommentsPreview(postId) } catch {}\r\n    }\r\n  }\r\n\r\n  async hardDeletePost(postId: ID) {\r\n    this.setPostProcessing(postId, true)\r\n    try {\r\n      try {\r\n        const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n        await Promise.allSettled(data.map(c => http.delete(`/comments/${c.id}`)))\r\n      } catch {}\r\n\r\n      const post = this.posts.find(p => p.id === postId)\r\n      if (post?.imageName) {\r\n        try { await http.delete(`/uploads/${encodeURIComponent(post.imageName)}`) } catch {}\r\n      }\r\n\r\n      await http.delete<void>(`/posts/${postId}`)\r\n\r\n      runInAction(() => {\r\n        this.posts = this.posts.filter(p => p.id !== postId)\r\n        delete this.commentsByPost[postId]\r\n        delete this.previewCommentsByPost[postId]\r\n        delete this.commentsCountByPost[postId]\r\n      })\r\n    } finally {\r\n      this.setPostProcessing(postId, false)\r\n    }\r\n  }\r\n\r\n  async fetchComments(postId: ID) {\r\n    const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n    data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n    runInAction(() => {\r\n      this.commentsByPost[postId] = data\r\n      this.commentsCountByPost[postId] = data.length\r\n      this.previewCommentsByPost[postId] = data.slice(0, 3) \r\n    })\r\n  }\r\n\r\n  async addComment(postId: ID, text: string) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      post_id: postId,\r\n      text,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl,\r\n      createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Comment>('/comments', payload)\r\n    runInAction(() => {\r\n      if (this.commentsByPost[postId]) {\r\n        const list = this.commentsByPost[postId]\r\n        this.commentsByPost[postId] = [...list, data].sort((a, b) =>\r\n          (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n      }\r\n\r\n      const prevCount = this.commentsCountByPost[postId] ?? 0\r\n      const newCount = prevCount + 1\r\n      this.commentsCountByPost[postId] = newCount\r\n\r\n      if (prevCount < 3) {\r\n        const prev = this.previewCommentsByPost[postId] ?? []\r\n        const merged = [...prev, data].sort((a, b) =>\r\n          (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n        this.previewCommentsByPost[postId] = merged.slice(0, 3)\r\n      }\r\n\r\n      this.posts = this.posts.map(p =>\r\n        p.id === postId ? { ...p, commentsCount: newCount } : p\r\n      )\r\n    })\r\n  }\r\n\r\n  async fetchUserAvatar(userId: ID): Promise<string> {\r\n    try {\r\n      const { data } = await http.get<{ avatarUrl: string }>(`/users/${userId}/avatar`)\r\n      return data.avatarUrl || DEFAULT_AVATAR\r\n    } catch (e) {\r\n      return DEFAULT_AVATAR\r\n    }\r\n  }\r\n\r\n  async hardDeleteComment(postId: ID, commentId: ID) {\r\n    this.setCommentProcessing(commentId, true)\r\n    try {\r\n      await http.delete<void>(`/comments/${commentId}`)\r\n      runInAction(() => {\r\n        if (this.commentsByPost[postId]) {\r\n          this.commentsByPost[postId] =\r\n            this.commentsByPost[postId].filter(c => c.id !== commentId)\r\n        }\r\n      })\r\n      await this.refreshCommentsPreview(postId)\r\n      runInAction(() => {\r\n        this.posts = this.posts.map(p =>\r\n          p.id === postId ? { ...p, commentsCount: this.commentsCount(postId) } : p\r\n        )\r\n      })\r\n    } finally {\r\n      this.setCommentProcessing(commentId, false)\r\n    }\r\n  }\r\n\r\n  async updateAllUserAvatarsOnServer(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      const userPosts = this.posts.filter(p => p.authorId === userId);\r\n      await Promise.allSettled(\r\n        userPosts.map(post => \r\n          http.patch(`/posts/${post.id}`, { authorAvatarUrl: newAvatarUrl })\r\n        )\r\n      );\r\n\r\n      const userComments: Comment[] = [];\r\n      Object.values(this.commentsByPost).forEach(comments => {\r\n        comments.filter(c => c.authorId === userId).forEach(c => userComments.push(c));\r\n      });\r\n      \r\n      await Promise.allSettled(\r\n        userComments.map(comment =>\r\n          http.patch(`/comments/${comment.id}`, { authorAvatarUrl: newAvatarUrl })\r\n        )\r\n      );\r\n    } catch (error) {\r\n      console.error('Ошибка при массовом обновлении аватаров на сервере:', error);\r\n    }\r\n  }\r\n\r\n  async updateAvatarInPostsAndComments(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      this.posts.forEach(post => {\r\n        if (post.authorId === userId) {\r\n          post.authorAvatarUrl = newAvatarUrl;\r\n        }\r\n      });\r\n\r\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\r\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\r\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      this.posts = [...this.posts];\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении аватарок в постах и комментариях:', error);\r\n    }\r\n  }\r\n\r\n  async updateAvatarOnServer(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      const payload = { avatarUrl: newAvatarUrl };\r\n      const response = await http.patch(`/users/${userId}`, payload);\r\n\r\n      if (response.status === 200) {\r\n        await this.updateAllUserAvatarsOnServer(userId, newAvatarUrl);\r\n        await this.updateAvatarInPostsAndComments(userId, newAvatarUrl);\r\n      } else {\r\n        throw new Error('Ошибка при обновлении аватарки на сервере');\r\n      }\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении аватарки на сервере:', error);\r\n    }\r\n  }\r\n\r\n  async refreshAvatarInCache(userId: ID, newAvatarUrl: string) {\r\n    runInAction(() => {\r\n      const currentAvatar = this.posts.find(p => p.authorId === userId)?.authorAvatarUrl;\r\n      if (currentAvatar === newAvatarUrl) return;\r\n\r\n      this.posts.forEach(post => {\r\n        if (post.authorId === userId) {\r\n          post.authorAvatarUrl = newAvatarUrl;\r\n        }\r\n      });\r\n\r\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\r\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\r\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      this.posts = [...this.posts];\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}