{"ast":null,"code":"import { makeAutoObservable, runInAction } from 'mobx';\nimport http from '../api/http';\nimport { DEFAULT_AVATAR } from 'constants/ui';\nexport class PostsStore {\n  constructor(auth) {\n    this.auth = void 0;\n    this.posts = [];\n    this.commentsByPost = {};\n    this.previewCommentsByPost = {};\n    this.commentsCountByPost = {};\n    this.isLoadingPosts = false;\n    this.errorPosts = null;\n    this.processingPosts = new Set();\n    this.processingComments = new Set();\n    makeAutoObservable(this);\n    this.auth = auth;\n  }\n  isPostProcessing(id) {\n    return this.processingPosts.has(id);\n  }\n  isCommentProcessing(id) {\n    return this.processingComments.has(id);\n  }\n  setPostProcessing(id, on) {\n    on ? this.processingPosts.add(id) : this.processingPosts.delete(id);\n  }\n  setCommentProcessing(id, on) {\n    on ? this.processingComments.add(id) : this.processingComments.delete(id);\n  }\n  comments(postId) {\n    var _this$commentsByPost$;\n    return (_this$commentsByPost$ = this.commentsByPost[postId]) !== null && _this$commentsByPost$ !== void 0 ? _this$commentsByPost$ : [];\n  }\n  commentsPreview(postId) {\n    var _this$previewComments;\n    return (_this$previewComments = this.previewCommentsByPost[postId]) !== null && _this$previewComments !== void 0 ? _this$previewComments : [];\n  }\n  commentsCount(postId) {\n    var _ref, _ref2, _this$commentsCountBy, _this$commentsByPost$2, _this$previewComments2;\n    return (_ref = (_ref2 = (_this$commentsCountBy = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy !== void 0 ? _this$commentsCountBy : (_this$commentsByPost$2 = this.commentsByPost[postId]) === null || _this$commentsByPost$2 === void 0 ? void 0 : _this$commentsByPost$2.length) !== null && _ref2 !== void 0 ? _ref2 : (_this$previewComments2 = this.previewCommentsByPost[postId]) === null || _this$previewComments2 === void 0 ? void 0 : _this$previewComments2.length) !== null && _ref !== void 0 ? _ref : 0;\n  }\n\n  // Функция для получения аватарки пользователя по его ID\n  async fetchUserAvatar(userId) {\n    try {\n      const {\n        data\n      } = await http.get(`/users/${userId}/avatar`);\n      return data.avatarUrl || DEFAULT_AVATAR; // Если аватарки нет, возвращаем дефолтную\n    } catch (e) {\n      return DEFAULT_AVATAR; // В случае ошибки — возвращаем дефолтную аватарку\n    }\n  }\n\n  // Функция для обновления аватарки в постах и комментариях\n  async updatePostAndCommentAvatars() {\n    for (const post of this.posts) {\n      const avatarUrl = await this.fetchUserAvatar(post.authorId);\n      post.authorAvatarUrl = avatarUrl; // Обновляем аватарку в посте\n    }\n\n    // Обновляем аватарки в комментариях\n    Object.keys(this.commentsByPost).forEach(k => {\n      const postId = Number(k);\n      this.commentsByPost[postId].forEach(comment => {\n        this.fetchUserAvatar(comment.authorId).then(avatarUrl => {\n          comment.authorAvatarUrl = avatarUrl; // Обновляем аватарку в комментариях\n        });\n      });\n    });\n  }\n\n  // Метод для обновления аватарок после создания нового поста\n  async createPost(input) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      description: input.description,\n      imageUrl: input.imageUrl,\n      imageName: input.imageName,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/posts', payload);\n    runInAction(() => {\n      this.posts.unshift(data);\n      this.previewCommentsByPost[data.id] = [];\n      this.commentsCountByPost[data.id] = 0;\n    });\n  }\n  async fetchPosts() {\n    this.isLoadingPosts = true;\n    this.errorPosts = null;\n    try {\n      const {\n        data\n      } = await http.get('/posts');\n      data.sort((a, b) => {\n        var _b$createdAt;\n        return ((_b$createdAt = b.createdAt) === null || _b$createdAt === void 0 ? void 0 : _b$createdAt.localeCompare(a.createdAt || '')) || 0;\n      });\n      runInAction(() => this.posts = data);\n    } catch (e) {\n      runInAction(() => {\n        var _e$response, _e$response$data;\n        return this.errorPosts = (e === null || e === void 0 ? void 0 : (_e$response = e.response) === null || _e$response === void 0 ? void 0 : (_e$response$data = _e$response.data) === null || _e$response$data === void 0 ? void 0 : _e$response$data.message) || 'Не удалось загрузить посты';\n      });\n    } finally {\n      runInAction(() => this.isLoadingPosts = false);\n    }\n  }\n  async addComment(postId, text) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      post_id: postId,\n      text,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/comments', payload);\n    runInAction(() => {\n      var _this$commentsCountBy2;\n      if (this.commentsByPost[postId]) {\n        const list = this.commentsByPost[postId];\n        this.commentsByPost[postId] = [...list, data].sort((a, b) => {\n          var _a$createdAt;\n          return ((_a$createdAt = a.createdAt) === null || _a$createdAt === void 0 ? void 0 : _a$createdAt.localeCompare(b.createdAt || '')) || 0;\n        });\n      }\n      const prevCount = (_this$commentsCountBy2 = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy2 !== void 0 ? _this$commentsCountBy2 : 0;\n      const newCount = prevCount + 1;\n      this.commentsCountByPost[postId] = newCount;\n      if (prevCount < 3) {\n        var _this$previewComments3;\n        const prev = (_this$previewComments3 = this.previewCommentsByPost[postId]) !== null && _this$previewComments3 !== void 0 ? _this$previewComments3 : [];\n        const merged = [...prev, data].sort((a, b) => {\n          var _a$createdAt2;\n          return ((_a$createdAt2 = a.createdAt) === null || _a$createdAt2 === void 0 ? void 0 : _a$createdAt2.localeCompare(b.createdAt || '')) || 0;\n        });\n        this.previewCommentsByPost[postId] = merged.slice(0, 3);\n      }\n      this.posts = this.posts.map(p => p.id === postId ? {\n        ...p,\n        commentsCount: newCount\n      } : p);\n    });\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","http","DEFAULT_AVATAR","PostsStore","constructor","auth","posts","commentsByPost","previewCommentsByPost","commentsCountByPost","isLoadingPosts","errorPosts","processingPosts","Set","processingComments","isPostProcessing","id","has","isCommentProcessing","setPostProcessing","on","add","delete","setCommentProcessing","comments","postId","_this$commentsByPost$","commentsPreview","_this$previewComments","commentsCount","_ref","_ref2","_this$commentsCountBy","_this$commentsByPost$2","_this$previewComments2","length","fetchUserAvatar","userId","data","get","avatarUrl","e","updatePostAndCommentAvatars","post","authorId","authorAvatarUrl","Object","keys","forEach","k","Number","comment","then","createPost","input","user","Error","payload","description","imageUrl","imageName","authorName","name","createdAt","Date","toISOString","unshift","fetchPosts","sort","a","b","_b$createdAt","localeCompare","_e$response","_e$response$data","response","message","addComment","text","post_id","_this$commentsCountBy2","list","_a$createdAt","prevCount","newCount","_this$previewComments3","prev","merged","_a$createdAt2","slice","map","p"],"sources":["C:/praka/www/media/src/stores/posts.store.ts"],"sourcesContent":["import { makeAutoObservable, runInAction } from 'mobx'\r\nimport http from '../api/http'\r\nimport type { ID, Post, Comment, CreatePostDTO } from '../types'\r\nimport type { AuthStore } from './auth.store'\r\nimport { DEFAULT_AVATAR } from 'constants/ui'\r\n\r\nexport class PostsStore {\r\n  private auth: AuthStore\r\n\r\n  posts: Post[] = []\r\n  commentsByPost: Record<ID, Comment[]> = {}\r\n  previewCommentsByPost: Record<ID, Comment[]> = {}\r\n  commentsCountByPost: Record<ID, number> = {}\r\n\r\n  isLoadingPosts = false\r\n  errorPosts: string | null = null\r\n\r\n  private processingPosts = new Set<ID>()\r\n  private processingComments = new Set<ID>()\r\n\r\n  constructor(auth: AuthStore) {\r\n    makeAutoObservable(this)\r\n    this.auth = auth\r\n  }\r\n\r\n  isPostProcessing(id: ID) { return this.processingPosts.has(id) }\r\n  isCommentProcessing(id: ID) { return this.processingComments.has(id) }\r\n  private setPostProcessing(id: ID, on: boolean) { on ? this.processingPosts.add(id) : this.processingPosts.delete(id) }\r\n  private setCommentProcessing(id: ID, on: boolean) { on ? this.processingComments.add(id) : this.processingComments.delete(id) }\r\n\r\n  comments(postId: ID) { return this.commentsByPost[postId] ?? [] }\r\n  commentsPreview(postId: ID) { return this.previewCommentsByPost[postId] ?? [] }\r\n  commentsCount(postId: ID) {\r\n    return this.commentsCountByPost[postId]\r\n      ?? this.commentsByPost[postId]?.length\r\n      ?? this.previewCommentsByPost[postId]?.length\r\n      ?? 0\r\n  }\r\n\r\n  // Функция для получения аватарки пользователя по его ID\r\n  async fetchUserAvatar(userId: ID): Promise<string> {\r\n    try {\r\n      const { data } = await http.get<{ avatarUrl: string }>(`/users/${userId}/avatar`)\r\n      return data.avatarUrl || DEFAULT_AVATAR // Если аватарки нет, возвращаем дефолтную\r\n    } catch (e) {\r\n      return DEFAULT_AVATAR // В случае ошибки — возвращаем дефолтную аватарку\r\n    }\r\n  }\r\n\r\n  // Функция для обновления аватарки в постах и комментариях\r\n  async updatePostAndCommentAvatars() {\r\n    for (const post of this.posts) {\r\n      const avatarUrl = await this.fetchUserAvatar(post.authorId)\r\n      post.authorAvatarUrl = avatarUrl // Обновляем аватарку в посте\r\n    }\r\n\r\n    // Обновляем аватарки в комментариях\r\n    Object.keys(this.commentsByPost).forEach(k => {\r\n      const postId = Number(k)\r\n      this.commentsByPost[postId].forEach(comment => {\r\n        this.fetchUserAvatar(comment.authorId).then(avatarUrl => {\r\n          comment.authorAvatarUrl = avatarUrl // Обновляем аватарку в комментариях\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  // Метод для обновления аватарок после создания нового поста\r\n  async createPost(input: CreatePostDTO) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      description: input.description,\r\n      imageUrl: input.imageUrl,\r\n      imageName: input.imageName,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl,\r\n      createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Post>('/posts', payload)\r\n    runInAction(() => {\r\n      this.posts.unshift(data)\r\n      this.previewCommentsByPost[data.id] = []\r\n      this.commentsCountByPost[data.id] = 0\r\n    })\r\n  }\r\n\r\n  async fetchPosts() {\r\n    this.isLoadingPosts = true\r\n    this.errorPosts = null\r\n    try {\r\n      const { data } = await http.get<Post[]>('/posts')\r\n      data.sort((a, b) => (b.createdAt?.localeCompare(a.createdAt || '') || 0))\r\n      runInAction(() => (this.posts = data))\r\n\r\n    } catch (e: any) {\r\n      runInAction(() => (this.errorPosts = e?.response?.data?.message || 'Не удалось загрузить посты'))\r\n    } finally {\r\n      runInAction(() => (this.isLoadingPosts = false))\r\n    }\r\n  }\r\n\r\n  async addComment(postId: ID, text: string) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n        post_id: postId,\r\n        text,\r\n        authorId: this.auth.user.id,\r\n        authorName: this.auth.user.name,\r\n        authorAvatarUrl: this.auth.user.avatarUrl,\r\n        createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Comment>('/comments', payload)\r\n    runInAction(() => {\r\n        if (this.commentsByPost[postId]) {\r\n        const list = this.commentsByPost[postId]\r\n        this.commentsByPost[postId] = [...list, data].sort((a, b) =>\r\n            (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n        }\r\n\r\n        const prevCount = this.commentsCountByPost[postId] ?? 0\r\n        const newCount = prevCount + 1\r\n        this.commentsCountByPost[postId] = newCount\r\n\r\n        if (prevCount < 3) {\r\n        const prev = this.previewCommentsByPost[postId] ?? []\r\n        const merged = [...prev, data].sort((a, b) =>\r\n            (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n        this.previewCommentsByPost[postId] = merged.slice(0, 3)\r\n        }\r\n\r\n        this.posts = this.posts.map(p =>\r\n        p.id === postId ? { ...p, commentsCount: newCount } : p\r\n        )\r\n    })\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}