{"ast":null,"code":"import { makeAutoObservable, runInAction } from 'mobx';\nimport http from '../api/http';\nexport class PostsStore {\n  constructor(auth) {\n    this.auth = void 0;\n    this.posts = [];\n    this.commentsByPost = {};\n    this.isLoadingPosts = false;\n    this.errorPosts = null;\n    this.processingPosts = new Set();\n    this.processingComments = new Set();\n    makeAutoObservable(this);\n    this.auth = auth;\n  }\n  isPostProcessing(id) {\n    return this.processingPosts.has(id);\n  }\n  isCommentProcessing(id) {\n    return this.processingComments.has(id);\n  }\n  setPostProcessing(id, on) {\n    on ? this.processingPosts.add(id) : this.processingPosts.delete(id);\n  }\n  setCommentProcessing(id, on) {\n    on ? this.processingComments.add(id) : this.processingComments.delete(id);\n  }\n  async uploadImage(file) {\n    var _data$data;\n    const fd = new FormData();\n    fd.append('file', file);\n    const {\n      data\n    } = await http.post('/uploads', fd, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    const item = Array.isArray(data) ? data[0] : (_data$data = data === null || data === void 0 ? void 0 : data.data) !== null && _data$data !== void 0 ? _data$data : data;\n    const url = (item === null || item === void 0 ? void 0 : item.url) || (item === null || item === void 0 ? void 0 : item.path) || (item === null || item === void 0 ? void 0 : item.src);\n    if (!url) throw new Error('Сервер не вернул ссылку на файл');\n    const clean = String(url).split('?')[0].split('#')[0];\n    const name = clean.substring(clean.lastIndexOf('/') + 1);\n    return {\n      url,\n      name\n    };\n  }\n  async fetchPosts() {\n    this.isLoadingPosts = true;\n    this.errorPosts = null;\n    try {\n      const {\n        data\n      } = await http.get('/posts');\n      data.sort((a, b) => {\n        var _b$createdAt;\n        return ((_b$createdAt = b.createdAt) === null || _b$createdAt === void 0 ? void 0 : _b$createdAt.localeCompare(a.createdAt || '')) || 0;\n      });\n      runInAction(() => this.posts = data);\n    } catch (e) {\n      runInAction(() => {\n        var _e$response, _e$response$data;\n        return this.errorPosts = (e === null || e === void 0 ? void 0 : (_e$response = e.response) === null || _e$response === void 0 ? void 0 : (_e$response$data = _e$response.data) === null || _e$response$data === void 0 ? void 0 : _e$response$data.message) || 'Не удалось загрузить посты';\n      });\n    } finally {\n      runInAction(() => this.isLoadingPosts = false);\n    }\n  }\n  async createPost(input) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      description: input.description,\n      imageUrl: input.imageUrl,\n      imageName: input.imageName,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      createdAt: new Date().toISOString(),\n      isDeleted: false\n    };\n    const {\n      data\n    } = await http.post('/posts', payload);\n    runInAction(() => {\n      this.posts.unshift(data);\n    });\n  }\n  async softDeletePost(postId) {\n    this.setPostProcessing(postId, true);\n    try {\n      const payload = {\n        isDeleted: true,\n        deletedAt: new Date().toISOString()\n      };\n      const {\n        data\n      } = await http.patch(`/posts/${postId}`, payload);\n      runInAction(() => {\n        this.posts = this.posts.map(p => p.id === postId ? data : p);\n      });\n    } finally {\n      this.setPostProcessing(postId, false);\n    }\n  }\n  async restorePost(postId) {\n    this.setPostProcessing(postId, true);\n    try {\n      const payload = {\n        isDeleted: false,\n        deletedAt: null\n      };\n      const {\n        data\n      } = await http.patch(`/posts/${postId}`, payload);\n      runInAction(() => {\n        this.posts = this.posts.map(p => p.id === postId ? data : p);\n      });\n    } finally {\n      this.setPostProcessing(postId, false);\n    }\n  }\n  async hardDeletePost(postId) {\n    this.setPostProcessing(postId, true);\n    try {\n      const post = this.posts.find(p => p.id === postId);\n      if (post !== null && post !== void 0 && post.imageName) {\n        try {\n          await http.delete(`/uploads/${encodeURIComponent(post.imageName)}`);\n        } catch {}\n      }\n      await http.delete(`/posts/${postId}`);\n      runInAction(() => {\n        this.posts = this.posts.filter(p => p.id !== postId);\n        delete this.commentsByPost[postId];\n      });\n    } finally {\n      this.setPostProcessing(postId, false);\n    }\n  }\n  comments(postId) {\n    var _this$commentsByPost$;\n    return (_this$commentsByPost$ = this.commentsByPost[postId]) !== null && _this$commentsByPost$ !== void 0 ? _this$commentsByPost$ : [];\n  }\n  async fetchComments(postId) {\n    try {\n      const {\n        data\n      } = await http.get(`/comments`, {\n        params: {\n          post_id: postId\n        }\n      });\n      data.sort((a, b) => {\n        var _a$createdAt;\n        return ((_a$createdAt = a.createdAt) === null || _a$createdAt === void 0 ? void 0 : _a$createdAt.localeCompare(b.createdAt || '')) || 0;\n      });\n      runInAction(() => {\n        this.commentsByPost[postId] = data;\n      });\n    } catch (e) {\n      var _e$response2, _e$response2$data;\n      if ((e === null || e === void 0 ? void 0 : (_e$response2 = e.response) === null || _e$response2 === void 0 ? void 0 : (_e$response2$data = _e$response2.data) === null || _e$response2$data === void 0 ? void 0 : _e$response2$data.name) === 'RESOURCE_NOT_FOUND') {\n        throw new Error('Ресурс /comments отсутствует в проекте Mokky');\n      }\n    }\n  }\n  async addComment(postId, text) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      post_id: postId,\n      text,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      createdAt: new Date().toISOString(),\n      isDeleted: false\n    };\n    const {\n      data\n    } = await http.post('/comments', payload);\n    runInAction(() => {\n      var _this$commentsByPost$2;\n      const list = (_this$commentsByPost$2 = this.commentsByPost[postId]) !== null && _this$commentsByPost$2 !== void 0 ? _this$commentsByPost$2 : [];\n      this.commentsByPost[postId] = [...list, data];\n      this.posts = this.posts.map(p => {\n        var _p$commentsCount;\n        return p.id === postId ? {\n          ...p,\n          commentsCount: ((_p$commentsCount = p.commentsCount) !== null && _p$commentsCount !== void 0 ? _p$commentsCount : 0) + 1\n        } : p;\n      });\n    });\n  }\n  async softDeleteComment(postId, commentId) {\n    this.setCommentProcessing(commentId, true);\n    try {\n      const payload = {\n        isDeleted: true,\n        deletedAt: new Date().toISOString()\n      };\n      const {\n        data\n      } = await http.patch(`/comments/${commentId}`, payload);\n      runInAction(() => {\n        var _this$commentsByPost$3;\n        this.commentsByPost[postId] = ((_this$commentsByPost$3 = this.commentsByPost[postId]) !== null && _this$commentsByPost$3 !== void 0 ? _this$commentsByPost$3 : []).map(c => c.id === commentId ? data : c);\n      });\n    } finally {\n      this.setCommentProcessing(commentId, false);\n    }\n  }\n  async restoreComment(postId, commentId) {\n    this.setCommentProcessing(commentId, true);\n    try {\n      const payload = {\n        isDeleted: false,\n        deletedAt: null\n      };\n      const {\n        data\n      } = await http.patch(`/comments/${commentId}`, payload);\n      runInAction(() => {\n        var _this$commentsByPost$4;\n        this.commentsByPost[postId] = ((_this$commentsByPost$4 = this.commentsByPost[postId]) !== null && _this$commentsByPost$4 !== void 0 ? _this$commentsByPost$4 : []).map(c => c.id === commentId ? data : c);\n      });\n    } finally {\n      this.setCommentProcessing(commentId, false);\n    }\n  }\n  async hardDeleteComment(postId, commentId) {\n    this.setCommentProcessing(commentId, true);\n    try {\n      await http.delete(`/comments/${commentId}`);\n      runInAction(() => {\n        var _this$commentsByPost$5;\n        this.commentsByPost[postId] = ((_this$commentsByPost$5 = this.commentsByPost[postId]) !== null && _this$commentsByPost$5 !== void 0 ? _this$commentsByPost$5 : []).filter(c => c.id !== commentId);\n        this.posts = this.posts.map(p => {\n          var _p$commentsCount2;\n          return p.id === postId ? {\n            ...p,\n            commentsCount: Math.max(((_p$commentsCount2 = p.commentsCount) !== null && _p$commentsCount2 !== void 0 ? _p$commentsCount2 : 1) - 1, 0)\n          } : p;\n        });\n      });\n    } finally {\n      this.setCommentProcessing(commentId, false);\n    }\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","http","PostsStore","constructor","auth","posts","commentsByPost","isLoadingPosts","errorPosts","processingPosts","Set","processingComments","isPostProcessing","id","has","isCommentProcessing","setPostProcessing","on","add","delete","setCommentProcessing","uploadImage","file","_data$data","fd","FormData","append","data","post","headers","item","Array","isArray","url","path","src","Error","clean","String","split","name","substring","lastIndexOf","fetchPosts","get","sort","a","b","_b$createdAt","createdAt","localeCompare","e","_e$response","_e$response$data","response","message","createPost","input","user","payload","description","imageUrl","imageName","authorId","authorName","Date","toISOString","isDeleted","unshift","softDeletePost","postId","deletedAt","patch","map","p","restorePost","hardDeletePost","find","encodeURIComponent","filter","comments","_this$commentsByPost$","fetchComments","params","post_id","_a$createdAt","_e$response2","_e$response2$data","addComment","text","_this$commentsByPost$2","list","_p$commentsCount","commentsCount","softDeleteComment","commentId","_this$commentsByPost$3","c","restoreComment","_this$commentsByPost$4","hardDeleteComment","_this$commentsByPost$5","_p$commentsCount2","Math","max"],"sources":["C:/praka/www/media/src/stores/posts.store.ts"],"sourcesContent":["import { makeAutoObservable, runInAction } from 'mobx'\r\nimport http from '../api/http'\r\nimport type { ID, Post, Comment, CreatePostDTO } from '../types'\r\nimport type { AuthStore } from './auth.store'\r\n\r\nexport class PostsStore {\r\n  private auth: AuthStore\r\n\r\n  posts: Post[] = []\r\n  commentsByPost: Record<ID, Comment[]> = {}\r\n\r\n  isLoadingPosts = false\r\n  errorPosts: string | null = null\r\n\r\n  private processingPosts = new Set<ID>()\r\n  private processingComments = new Set<ID>()\r\n\r\n  constructor(auth: AuthStore) {\r\n    makeAutoObservable(this)\r\n    this.auth = auth\r\n  }\r\n\r\n  isPostProcessing(id: ID) { return this.processingPosts.has(id) }\r\n  isCommentProcessing(id: ID) { return this.processingComments.has(id) }\r\n  private setPostProcessing(id: ID, on: boolean) { on ? this.processingPosts.add(id) : this.processingPosts.delete(id) }\r\n  private setCommentProcessing(id: ID, on: boolean) { on ? this.processingComments.add(id) : this.processingComments.delete(id) }\r\n\r\n    async uploadImage(file: File): Promise<{ url: string; name: string }> {\r\n    const fd = new FormData()\r\n    fd.append('file', file)\r\n\r\n    const { data } = await http.post<any>('/uploads', fd, {\r\n        headers: { 'Content-Type': 'multipart/form-data' },\r\n    })\r\n\r\n    const item = Array.isArray(data) ? data[0] : (data?.data ?? data)\r\n    const url: string = item?.url || item?.path || item?.src\r\n    if (!url) throw new Error('Сервер не вернул ссылку на файл')\r\n\r\n    const clean = String(url).split('?')[0].split('#')[0]\r\n    const name = clean.substring(clean.lastIndexOf('/') + 1) \r\n\r\n    return { url, name }\r\n    }\r\n\r\n  async fetchPosts() {\r\n    this.isLoadingPosts = true\r\n    this.errorPosts = null\r\n    try {\r\n      const { data } = await http.get<Post[]>('/posts')\r\n      data.sort((a, b) => (b.createdAt?.localeCompare(a.createdAt || '') || 0))\r\n      runInAction(() => (this.posts = data))\r\n    } catch (e: any) {\r\n      runInAction(() => (this.errorPosts = e?.response?.data?.message || 'Не удалось загрузить посты'))\r\n    } finally {\r\n      runInAction(() => (this.isLoadingPosts = false))\r\n    }\r\n  }\r\n\r\n  async createPost(input: CreatePostDTO) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      description: input.description,\r\n      imageUrl: input.imageUrl,\r\n      imageName: input.imageName,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      createdAt: new Date().toISOString(),\r\n      isDeleted: false\r\n    }\r\n    const { data } = await http.post<Post>('/posts', payload)\r\n    runInAction(() => { this.posts.unshift(data) })\r\n  }\r\n\r\n  async softDeletePost(postId: ID) {\r\n    this.setPostProcessing(postId, true)\r\n    try {\r\n      const payload = { isDeleted: true, deletedAt: new Date().toISOString() }\r\n      const { data } = await http.patch<Post>(`/posts/${postId}`, payload)\r\n      runInAction(() => {\r\n        this.posts = this.posts.map(p => p.id === postId ? data : p)\r\n      })\r\n    } finally {\r\n      this.setPostProcessing(postId, false)\r\n    }\r\n  }\r\n\r\n  async restorePost(postId: ID) {\r\n    this.setPostProcessing(postId, true)\r\n    try {\r\n      const payload = { isDeleted: false, deletedAt: null }\r\n      const { data } = await http.patch<Post>(`/posts/${postId}`, payload as any)\r\n      runInAction(() => {\r\n        this.posts = this.posts.map(p => p.id === postId ? data : p)\r\n      })\r\n    } finally {\r\n      this.setPostProcessing(postId, false)\r\n    }\r\n  }\r\n\r\n  async hardDeletePost(postId: ID) {\r\n    this.setPostProcessing(postId, true)\r\n    try {\r\n      const post = this.posts.find(p => p.id === postId)\r\n      if (post?.imageName) {\r\n        try { await http.delete(`/uploads/${encodeURIComponent(post.imageName)}`) } catch {}\r\n      }\r\n      await http.delete<void>(`/posts/${postId}`)\r\n      runInAction(() => {\r\n        this.posts = this.posts.filter(p => p.id !== postId)\r\n        delete this.commentsByPost[postId]\r\n      })\r\n    } finally {\r\n      this.setPostProcessing(postId, false)\r\n    }\r\n  }\r\n  comments(postId: ID) {\r\n    return this.commentsByPost[postId] ?? []\r\n  }\r\n\r\n  async fetchComments(postId: ID) {\r\n    try {\r\n      const { data } = await http.get<Comment[]>(`/comments`, { params: { post_id: postId } })\r\n      data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n      runInAction(() => { this.commentsByPost[postId] = data })\r\n    } catch (e: any) {\r\n      if (e?.response?.data?.name === 'RESOURCE_NOT_FOUND') {\r\n        throw new Error('Ресурс /comments отсутствует в проекте Mokky')\r\n      }\r\n    }\r\n  }\r\n\r\n  async addComment(postId: ID, text: string) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      post_id: postId,                   \r\n      text,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      createdAt: new Date().toISOString(),\r\n      isDeleted: false\r\n    }\r\n    const { data } = await http.post<Comment>('/comments', payload)\r\n    runInAction(() => {\r\n      const list = this.commentsByPost[postId] ?? []\r\n      this.commentsByPost[postId] = [...list, data]\r\n      this.posts = this.posts.map(p => p.id === postId ? { ...p, commentsCount: (p.commentsCount ?? 0) + 1 } : p)\r\n    })\r\n  }\r\n\r\n  async softDeleteComment(postId: ID, commentId: ID) {\r\n    this.setCommentProcessing(commentId, true)\r\n    try {\r\n      const payload = { isDeleted: true, deletedAt: new Date().toISOString() }\r\n      const { data } = await http.patch<Comment>(`/comments/${commentId}`, payload)\r\n      runInAction(() => {\r\n        this.commentsByPost[postId] = (this.commentsByPost[postId] ?? []).map(c => c.id === commentId ? data : c)\r\n      })\r\n    } finally {\r\n      this.setCommentProcessing(commentId, false)\r\n    }\r\n  }\r\n\r\n  async restoreComment(postId: ID, commentId: ID) {\r\n    this.setCommentProcessing(commentId, true)\r\n    try {\r\n      const payload = { isDeleted: false, deletedAt: null }\r\n      const { data } = await http.patch<Comment>(`/comments/${commentId}`, payload as any)\r\n      runInAction(() => {\r\n        this.commentsByPost[postId] = (this.commentsByPost[postId] ?? []).map(c => c.id === commentId ? data : c)\r\n      })\r\n    } finally {\r\n      this.setCommentProcessing(commentId, false)\r\n    }\r\n  }\r\n\r\n  async hardDeleteComment(postId: ID, commentId: ID) {\r\n    this.setCommentProcessing(commentId, true)\r\n    try {\r\n      await http.delete<void>(`/comments/${commentId}`)\r\n      runInAction(() => {\r\n        this.commentsByPost[postId] = (this.commentsByPost[postId] ?? []).filter(c => c.id !== commentId)\r\n        this.posts = this.posts.map(p => p.id === postId ? { ...p, commentsCount: Math.max((p.commentsCount ?? 1) - 1, 0) } : p)\r\n      })\r\n    } finally {\r\n      this.setCommentProcessing(commentId, false)\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}