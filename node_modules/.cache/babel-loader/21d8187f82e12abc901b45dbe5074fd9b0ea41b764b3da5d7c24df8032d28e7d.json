{"ast":null,"code":"import { makeAutoObservable, runInAction } from 'mobx';\nimport http from '../api/http';\nimport { DEFAULT_AVATAR } from 'constants/ui';\nexport class PostsStore {\n  constructor(auth) {\n    this.auth = void 0;\n    this.posts = [];\n    this.commentsByPost = {};\n    this.previewCommentsByPost = {};\n    this.commentsCountByPost = {};\n    this.isLoadingPosts = false;\n    this.errorPosts = null;\n    this.processingPosts = new Set();\n    this.processingComments = new Set();\n    makeAutoObservable(this);\n    this.auth = auth;\n  }\n  isPostProcessing(id) {\n    return this.processingPosts.has(id);\n  }\n  isCommentProcessing(id) {\n    return this.processingComments.has(id);\n  }\n  setPostProcessing(id, on) {\n    on ? this.processingPosts.add(id) : this.processingPosts.delete(id);\n  }\n  setCommentProcessing(id, on) {\n    on ? this.processingComments.add(id) : this.processingComments.delete(id);\n  }\n  comments(postId) {\n    var _this$commentsByPost$;\n    return (_this$commentsByPost$ = this.commentsByPost[postId]) !== null && _this$commentsByPost$ !== void 0 ? _this$commentsByPost$ : [];\n  }\n  commentsPreview(postId) {\n    var _this$previewComments;\n    return (_this$previewComments = this.previewCommentsByPost[postId]) !== null && _this$previewComments !== void 0 ? _this$previewComments : [];\n  }\n  commentsCount(postId) {\n    var _ref, _ref2, _this$commentsCountBy, _this$commentsByPost$2, _this$previewComments2;\n    return (_ref = (_ref2 = (_this$commentsCountBy = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy !== void 0 ? _this$commentsCountBy : (_this$commentsByPost$2 = this.commentsByPost[postId]) === null || _this$commentsByPost$2 === void 0 ? void 0 : _this$commentsByPost$2.length) !== null && _ref2 !== void 0 ? _ref2 : (_this$previewComments2 = this.previewCommentsByPost[postId]) === null || _this$previewComments2 === void 0 ? void 0 : _this$previewComments2.length) !== null && _ref !== void 0 ? _ref : 0;\n  }\n  async uploadImage(file) {\n    var _data$data;\n    const fd = new FormData();\n    fd.append('file', file);\n    const {\n      data\n    } = await http.post('/uploads', fd, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    const item = Array.isArray(data) ? data[0] : (_data$data = data === null || data === void 0 ? void 0 : data.data) !== null && _data$data !== void 0 ? _data$data : data;\n    const url = (item === null || item === void 0 ? void 0 : item.url) || (item === null || item === void 0 ? void 0 : item.path) || (item === null || item === void 0 ? void 0 : item.src);\n    if (!url) throw new Error('Сервер не вернул ссылку на файл');\n    const clean = String(url).split('?')[0].split('#')[0];\n    const name = clean.substring(clean.lastIndexOf('/') + 1);\n    return {\n      url,\n      name\n    };\n  }\n  async fetchPosts() {\n    this.isLoadingPosts = true;\n    this.errorPosts = null;\n    try {\n      const {\n        data\n      } = await http.get('/posts');\n      data.sort((a, b) => {\n        var _b$createdAt;\n        return ((_b$createdAt = b.createdAt) === null || _b$createdAt === void 0 ? void 0 : _b$createdAt.localeCompare(a.createdAt || '')) || 0;\n      });\n      runInAction(() => this.posts = data);\n    } catch (e) {\n      runInAction(() => {\n        var _e$response, _e$response$data;\n        return this.errorPosts = (e === null || e === void 0 ? void 0 : (_e$response = e.response) === null || _e$response === void 0 ? void 0 : (_e$response$data = _e$response.data) === null || _e$response$data === void 0 ? void 0 : _e$response$data.message) || 'Не удалось загрузить посты';\n      });\n    } finally {\n      runInAction(() => this.isLoadingPosts = false);\n    }\n  }\n  async createPost(input) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      description: input.description,\n      imageUrl: input.imageUrl,\n      imageName: input.imageName,\n      authorId: this.auth.user.id,\n      // Только ID, аватар будем подтягивать из пользователя\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/posts', payload);\n\n    // Дополняем данные на клиенте\n    const postWithUserData = {\n      ...data,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl\n    };\n    runInAction(() => {\n      this.posts.unshift(postWithUserData);\n      this.previewCommentsByPost[data.id] = [];\n      this.commentsCountByPost[data.id] = 0;\n    });\n  }\n  async refreshCommentsPreview(postId) {\n    const {\n      data\n    } = await http.get('/comments', {\n      params: {\n        post_id: postId\n      }\n    });\n    data.sort((a, b) => {\n      var _a$createdAt;\n      return ((_a$createdAt = a.createdAt) === null || _a$createdAt === void 0 ? void 0 : _a$createdAt.localeCompare(b.createdAt || '')) || 0;\n    });\n    const first3 = data.slice(0, 3);\n    runInAction(() => {\n      this.previewCommentsByPost[postId] = first3;\n      this.commentsCountByPost[postId] = data.length;\n    });\n  }\n  async ensureCommentsPreview(postId) {\n    if (this.commentsCountByPost[postId] === undefined) {\n      try {\n        await this.refreshCommentsPreview(postId);\n      } catch {}\n    }\n  }\n  async hardDeletePost(postId) {\n    this.setPostProcessing(postId, true);\n    try {\n      try {\n        const {\n          data\n        } = await http.get('/comments', {\n          params: {\n            post_id: postId\n          }\n        });\n        await Promise.allSettled(data.map(c => http.delete(`/comments/${c.id}`)));\n      } catch {}\n      const post = this.posts.find(p => p.id === postId);\n      if (post !== null && post !== void 0 && post.imageName) {\n        try {\n          await http.delete(`/uploads/${encodeURIComponent(post.imageName)}`);\n        } catch {}\n      }\n      await http.delete(`/posts/${postId}`);\n      runInAction(() => {\n        this.posts = this.posts.filter(p => p.id !== postId);\n        delete this.commentsByPost[postId];\n        delete this.previewCommentsByPost[postId];\n        delete this.commentsCountByPost[postId];\n      });\n    } finally {\n      this.setPostProcessing(postId, false);\n    }\n  }\n  async fetchComments(postId) {\n    const {\n      data\n    } = await http.get('/comments', {\n      params: {\n        post_id: postId\n      }\n    });\n    data.sort((a, b) => {\n      var _a$createdAt2;\n      return ((_a$createdAt2 = a.createdAt) === null || _a$createdAt2 === void 0 ? void 0 : _a$createdAt2.localeCompare(b.createdAt || '')) || 0;\n    });\n    runInAction(() => {\n      this.commentsByPost[postId] = data;\n      this.commentsCountByPost[postId] = data.length;\n      this.previewCommentsByPost[postId] = data.slice(0, 3); // Обновляем все комментарии\n    });\n  }\n  async addComment(postId, text) {\n    if (!this.auth.user) throw new Error('Требуется вход');\n    const payload = {\n      post_id: postId,\n      text,\n      authorId: this.auth.user.id,\n      authorName: this.auth.user.name,\n      authorAvatarUrl: this.auth.user.avatarUrl,\n      createdAt: new Date().toISOString()\n    };\n    const {\n      data\n    } = await http.post('/comments', payload);\n    runInAction(() => {\n      var _this$commentsCountBy2;\n      if (this.commentsByPost[postId]) {\n        const list = this.commentsByPost[postId];\n        this.commentsByPost[postId] = [...list, data].sort((a, b) => {\n          var _a$createdAt3;\n          return ((_a$createdAt3 = a.createdAt) === null || _a$createdAt3 === void 0 ? void 0 : _a$createdAt3.localeCompare(b.createdAt || '')) || 0;\n        });\n      }\n      const prevCount = (_this$commentsCountBy2 = this.commentsCountByPost[postId]) !== null && _this$commentsCountBy2 !== void 0 ? _this$commentsCountBy2 : 0;\n      const newCount = prevCount + 1;\n      this.commentsCountByPost[postId] = newCount;\n      if (prevCount < 3) {\n        var _this$previewComments3;\n        const prev = (_this$previewComments3 = this.previewCommentsByPost[postId]) !== null && _this$previewComments3 !== void 0 ? _this$previewComments3 : [];\n        const merged = [...prev, data].sort((a, b) => {\n          var _a$createdAt4;\n          return ((_a$createdAt4 = a.createdAt) === null || _a$createdAt4 === void 0 ? void 0 : _a$createdAt4.localeCompare(b.createdAt || '')) || 0;\n        });\n        this.previewCommentsByPost[postId] = merged.slice(0, 3);\n      }\n      this.posts = this.posts.map(p => p.id === postId ? {\n        ...p,\n        commentsCount: newCount\n      } : p);\n    });\n  }\n  async fetchUserAvatar(userId) {\n    try {\n      const {\n        data\n      } = await http.get(`/users/${userId}/avatar`);\n      return data.avatarUrl || DEFAULT_AVATAR;\n    } catch (e) {\n      return DEFAULT_AVATAR;\n    }\n  }\n  async hardDeleteComment(postId, commentId) {\n    this.setCommentProcessing(commentId, true);\n    try {\n      await http.delete(`/comments/${commentId}`);\n      runInAction(() => {\n        if (this.commentsByPost[postId]) {\n          this.commentsByPost[postId] = this.commentsByPost[postId].filter(c => c.id !== commentId);\n        }\n      });\n      await this.refreshCommentsPreview(postId);\n      runInAction(() => {\n        this.posts = this.posts.map(p => p.id === postId ? {\n          ...p,\n          commentsCount: this.commentsCount(postId)\n        } : p);\n      });\n    } finally {\n      this.setCommentProcessing(commentId, false);\n    }\n  }\n  async updateAllUserAvatarsOnServer(userId, newAvatarUrl) {\n    try {\n      console.log('Массовое обновление аватаров на сервере для пользователя:', userId);\n\n      // 1. Обновляем аватарки в постах на сервере\n      const userPosts = this.posts.filter(p => p.authorId === userId);\n      await Promise.allSettled(userPosts.map(post => http.patch(`/posts/${post.id}`, {\n        authorAvatarUrl: newAvatarUrl\n      })));\n\n      // 2. Обновляем аватарки в комментариях на сервере\n      const userComments = [];\n      Object.values(this.commentsByPost).forEach(comments => {\n        comments.filter(c => c.authorId === userId).forEach(c => userComments.push(c));\n      });\n      await Promise.allSettled(userComments.map(comment => http.patch(`/comments/${comment.id}`, {\n        authorAvatarUrl: newAvatarUrl\n      })));\n      console.log('Все аватарки обновлены на сервере');\n    } catch (error) {\n      console.error('Ошибка при массовом обновлении аватаров на сервере:', error);\n    }\n  }\n  async updateAvatarInPostsAndComments(userId, newAvatarUrl) {\n    try {\n      // Обновляем аватарку во всех постах\n      this.posts.forEach(post => {\n        if (post.authorId === userId) {\n          post.authorAvatarUrl = newAvatarUrl; // Обновляем аватарку в постах\n        }\n      });\n\n      // Обновляем аватарку во всех комментариях (не только preview)\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            }; // Обновляем аватарку в комментариях\n          }\n          return comment;\n        });\n      });\n\n      // Обновляем аватарки в preview комментариях\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            }; // Обновляем аватарку в preview комментариях\n          }\n          return comment;\n        });\n      });\n\n      // Принудительно обновляем массивы для MobX\n      this.posts = [...this.posts];\n      console.log('Аватарки обновлены в постах и комментариях');\n    } catch (error) {\n      console.error('Ошибка при обновлении аватарок в постах и комментариях:', error);\n    }\n  }\n  async updateAvatarOnServer(userId, newAvatarUrl) {\n    try {\n      const payload = {\n        avatarUrl: newAvatarUrl\n      };\n      console.log(`Отправляем запрос на сервер для обновления аватарки пользователя ${userId}`);\n      const response = await http.patch(`/users/${userId}`, payload);\n      console.log('Ответ от сервера при обновлении аватарки:', response);\n\n      // Обновляем аватарки во всех связанных данных на сервере\n      await this.updateAllUserAvatarsOnServer(userId, newAvatarUrl);\n\n      // И только потом обновляем на клиенте\n      await this.updateAvatarInPostsAndComments(userId, newAvatarUrl);\n    } catch (error) {\n      console.error('Ошибка при обновлении аватарки на сервере:', error);\n    }\n  }\n  async refreshAvatarInCache(userId, newAvatarUrl) {\n    runInAction(() => {\n      var _this$posts$find;\n      // Проверяем, действительно ли нужно обновлять\n      const currentAvatar = (_this$posts$find = this.posts.find(p => p.authorId === userId)) === null || _this$posts$find === void 0 ? void 0 : _this$posts$find.authorAvatarUrl;\n      if (currentAvatar === newAvatarUrl) {\n        console.log('Аватар уже актуален, пропускаем обновление');\n        return;\n      }\n      console.log('Обновление аватарки для пользователя:', userId, 'новая ссылка:', newAvatarUrl);\n\n      // 1. Обновляем аватарку в постах\n      this.posts.forEach(post => {\n        if (post.authorId === userId) {\n          console.log(`Обновляем аватарку в посте ${post.id}`);\n          post.authorAvatarUrl = newAvatarUrl;\n        }\n      });\n\n      // 2. Обновляем аватарку в комментариях\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            console.log(`Обновляем аватарку в комментарии ${comment.id} поста ${postId}`);\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n\n      // 3. Обновляем аватарку в preview комментариях\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\n          if (comment.authorId === userId) {\n            console.log(`Обновляем аватарку в preview комментарии ${comment.id} поста ${postId}`);\n            return {\n              ...comment,\n              authorAvatarUrl: newAvatarUrl\n            };\n          }\n          return comment;\n        });\n      });\n\n      // 4. Принудительно обновляем массивы для MobX\n      this.posts = [...this.posts];\n      console.log('Аватарки обновлены');\n    });\n  }\n}","map":{"version":3,"names":["makeAutoObservable","runInAction","http","DEFAULT_AVATAR","PostsStore","constructor","auth","posts","commentsByPost","previewCommentsByPost","commentsCountByPost","isLoadingPosts","errorPosts","processingPosts","Set","processingComments","isPostProcessing","id","has","isCommentProcessing","setPostProcessing","on","add","delete","setCommentProcessing","comments","postId","_this$commentsByPost$","commentsPreview","_this$previewComments","commentsCount","_ref","_ref2","_this$commentsCountBy","_this$commentsByPost$2","_this$previewComments2","length","uploadImage","file","_data$data","fd","FormData","append","data","post","headers","item","Array","isArray","url","path","src","Error","clean","String","split","name","substring","lastIndexOf","fetchPosts","get","sort","a","b","_b$createdAt","createdAt","localeCompare","e","_e$response","_e$response$data","response","message","createPost","input","user","payload","description","imageUrl","imageName","authorId","Date","toISOString","postWithUserData","authorName","authorAvatarUrl","avatarUrl","unshift","refreshCommentsPreview","params","post_id","_a$createdAt","first3","slice","ensureCommentsPreview","undefined","hardDeletePost","Promise","allSettled","map","c","find","p","encodeURIComponent","filter","fetchComments","_a$createdAt2","addComment","text","_this$commentsCountBy2","list","_a$createdAt3","prevCount","newCount","_this$previewComments3","prev","merged","_a$createdAt4","fetchUserAvatar","userId","hardDeleteComment","commentId","updateAllUserAvatarsOnServer","newAvatarUrl","console","log","userPosts","patch","userComments","Object","values","forEach","push","comment","error","updateAvatarInPostsAndComments","entries","Number","updateAvatarOnServer","refreshAvatarInCache","_this$posts$find","currentAvatar"],"sources":["C:/praka/www/media/src/stores/posts.store.ts"],"sourcesContent":["import { makeAutoObservable, runInAction } from 'mobx'\r\nimport http from '../api/http'\r\nimport type { ID, Post, Comment, CreatePostDTO } from '../types'\r\nimport type { AuthStore } from './auth.store'\r\nimport { DEFAULT_AVATAR } from 'constants/ui'\r\n\r\nexport class PostsStore {\r\n  private auth: AuthStore\r\n\r\n  posts: Post[] = []\r\n  commentsByPost: Record<ID, Comment[]> = {}\r\n  previewCommentsByPost: Record<ID, Comment[]> = {}\r\n  commentsCountByPost: Record<ID, number> = {}\r\n\r\n  isLoadingPosts = false\r\n  errorPosts: string | null = null\r\n\r\n  private processingPosts = new Set<ID>()\r\n  private processingComments = new Set<ID>()\r\n\r\n  constructor(auth: AuthStore) {\r\n    makeAutoObservable(this)\r\n    this.auth = auth\r\n  }\r\n\r\n  isPostProcessing(id: ID) { return this.processingPosts.has(id) }\r\n  isCommentProcessing(id: ID) { return this.processingComments.has(id) }\r\n  private setPostProcessing(id: ID, on: boolean) { on ? this.processingPosts.add(id) : this.processingPosts.delete(id) }\r\n  private setCommentProcessing(id: ID, on: boolean) { on ? this.processingComments.add(id) : this.processingComments.delete(id) }\r\n\r\n  comments(postId: ID) { return this.commentsByPost[postId] ?? [] }\r\n  commentsPreview(postId: ID) { return this.previewCommentsByPost[postId] ?? [] }\r\n  commentsCount(postId: ID) {\r\n    return this.commentsCountByPost[postId]\r\n      ?? this.commentsByPost[postId]?.length\r\n      ?? this.previewCommentsByPost[postId]?.length\r\n      ?? 0\r\n  }\r\n\r\n  async uploadImage(file: File): Promise<{ url: string; name: string }> {\r\n    const fd = new FormData()\r\n    fd.append('file', file)\r\n\r\n    const { data } = await http.post<any>('/uploads', fd, {\r\n      headers: { 'Content-Type': 'multipart/form-data' },\r\n    })\r\n\r\n    const item = Array.isArray(data) ? data[0] : (data?.data ?? data)\r\n    const url: string = item?.url || item?.path || item?.src\r\n    if (!url) throw new Error('Сервер не вернул ссылку на файл')\r\n\r\n    const clean = String(url).split('?')[0].split('#')[0]\r\n    const name = clean.substring(clean.lastIndexOf('/') + 1)\r\n\r\n    return { url, name }\r\n  }\r\n\r\n  async fetchPosts() {\r\n    this.isLoadingPosts = true\r\n    this.errorPosts = null\r\n    try {\r\n      const { data } = await http.get<Post[]>('/posts')\r\n      data.sort((a, b) => (b.createdAt?.localeCompare(a.createdAt || '') || 0))\r\n      runInAction(() => (this.posts = data))\r\n\r\n    } catch (e: any) {\r\n      runInAction(() => (this.errorPosts = e?.response?.data?.message || 'Не удалось загрузить посты'))\r\n    } finally {\r\n      runInAction(() => (this.isLoadingPosts = false))\r\n    }\r\n  }\r\n\r\n  async createPost(input: CreatePostDTO) {\r\n    if (!this.auth.user) throw new Error('Требуется вход');\r\n    const payload = {\r\n      description: input.description,\r\n      imageUrl: input.imageUrl,\r\n      imageName: input.imageName,\r\n      authorId: this.auth.user.id, // Только ID, аватар будем подтягивать из пользователя\r\n      createdAt: new Date().toISOString()\r\n    };\r\n    const { data } = await http.post<Post>('/posts', payload);\r\n    \r\n    // Дополняем данные на клиенте\r\n    const postWithUserData = {\r\n      ...data,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl\r\n    };\r\n    \r\n    runInAction(() => {\r\n      this.posts.unshift(postWithUserData);\r\n      this.previewCommentsByPost[data.id] = [];\r\n      this.commentsCountByPost[data.id] = 0;\r\n    });\r\n  }\r\n\r\n  async refreshCommentsPreview(postId: ID) {\r\n    const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n    data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n    const first3 = data.slice(0, 3)\r\n    runInAction(() => {\r\n      this.previewCommentsByPost[postId] = first3\r\n      this.commentsCountByPost[postId] = data.length\r\n    })\r\n  }\r\n\r\n  async ensureCommentsPreview(postId: ID) {\r\n    if (this.commentsCountByPost[postId] === undefined) {\r\n      try { await this.refreshCommentsPreview(postId) } catch {}\r\n    }\r\n  }\r\n\r\n  async hardDeletePost(postId: ID) {\r\n    this.setPostProcessing(postId, true)\r\n    try {\r\n      try {\r\n        const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n        await Promise.allSettled(data.map(c => http.delete(`/comments/${c.id}`)))\r\n      } catch {}\r\n\r\n      const post = this.posts.find(p => p.id === postId)\r\n      if (post?.imageName) {\r\n        try { await http.delete(`/uploads/${encodeURIComponent(post.imageName)}`) } catch {}\r\n      }\r\n\r\n      await http.delete<void>(`/posts/${postId}`)\r\n\r\n      runInAction(() => {\r\n        this.posts = this.posts.filter(p => p.id !== postId)\r\n        delete this.commentsByPost[postId]\r\n        delete this.previewCommentsByPost[postId]\r\n        delete this.commentsCountByPost[postId]\r\n      })\r\n    } finally {\r\n      this.setPostProcessing(postId, false)\r\n    }\r\n  }\r\n\r\n  async fetchComments(postId: ID) {\r\n    const { data } = await http.get<Comment[]>('/comments', { params: { post_id: postId } })\r\n    data.sort((a, b) => (a.createdAt?.localeCompare(b.createdAt || '') || 0))\r\n    runInAction(() => {\r\n      this.commentsByPost[postId] = data\r\n      this.commentsCountByPost[postId] = data.length\r\n      this.previewCommentsByPost[postId] = data.slice(0, 3) // Обновляем все комментарии\r\n    })\r\n  }\r\n\r\n  async addComment(postId: ID, text: string) {\r\n    if (!this.auth.user) throw new Error('Требуется вход')\r\n    const payload = {\r\n      post_id: postId,\r\n      text,\r\n      authorId: this.auth.user.id,\r\n      authorName: this.auth.user.name,\r\n      authorAvatarUrl: this.auth.user.avatarUrl,\r\n      createdAt: new Date().toISOString()\r\n    }\r\n    const { data } = await http.post<Comment>('/comments', payload)\r\n    runInAction(() => {\r\n      if (this.commentsByPost[postId]) {\r\n        const list = this.commentsByPost[postId]\r\n        this.commentsByPost[postId] = [...list, data].sort((a, b) =>\r\n          (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n      }\r\n\r\n      const prevCount = this.commentsCountByPost[postId] ?? 0\r\n      const newCount = prevCount + 1\r\n      this.commentsCountByPost[postId] = newCount\r\n\r\n      if (prevCount < 3) {\r\n        const prev = this.previewCommentsByPost[postId] ?? []\r\n        const merged = [...prev, data].sort((a, b) =>\r\n          (a.createdAt?.localeCompare(b.createdAt || '') || 0)\r\n        )\r\n        this.previewCommentsByPost[postId] = merged.slice(0, 3)\r\n      }\r\n\r\n      this.posts = this.posts.map(p =>\r\n        p.id === postId ? { ...p, commentsCount: newCount } : p\r\n      )\r\n    })\r\n  }\r\n\r\n  async fetchUserAvatar(userId: ID): Promise<string> {\r\n    try {\r\n      const { data } = await http.get<{ avatarUrl: string }>(`/users/${userId}/avatar`)\r\n      return data.avatarUrl || DEFAULT_AVATAR\r\n    } catch (e) {\r\n      return DEFAULT_AVATAR\r\n    }\r\n  }\r\n\r\n  async hardDeleteComment(postId: ID, commentId: ID) {\r\n    this.setCommentProcessing(commentId, true)\r\n    try {\r\n      await http.delete<void>(`/comments/${commentId}`)\r\n      runInAction(() => {\r\n        if (this.commentsByPost[postId]) {\r\n          this.commentsByPost[postId] =\r\n            this.commentsByPost[postId].filter(c => c.id !== commentId)\r\n        }\r\n      })\r\n      await this.refreshCommentsPreview(postId)\r\n      runInAction(() => {\r\n        this.posts = this.posts.map(p =>\r\n          p.id === postId ? { ...p, commentsCount: this.commentsCount(postId) } : p\r\n        )\r\n      })\r\n    } finally {\r\n      this.setCommentProcessing(commentId, false)\r\n    }\r\n  }\r\n  async updateAllUserAvatarsOnServer(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      console.log('Массовое обновление аватаров на сервере для пользователя:', userId);\r\n      \r\n      // 1. Обновляем аватарки в постах на сервере\r\n      const userPosts = this.posts.filter(p => p.authorId === userId);\r\n      await Promise.allSettled(\r\n        userPosts.map(post => \r\n          http.patch(`/posts/${post.id}`, { authorAvatarUrl: newAvatarUrl })\r\n        )\r\n      );\r\n\r\n      // 2. Обновляем аватарки в комментариях на сервере\r\n      const userComments: Comment[] = [];\r\n      Object.values(this.commentsByPost).forEach(comments => {\r\n        comments.filter(c => c.authorId === userId).forEach(c => userComments.push(c));\r\n      });\r\n      \r\n      await Promise.allSettled(\r\n        userComments.map(comment =>\r\n          http.patch(`/comments/${comment.id}`, { authorAvatarUrl: newAvatarUrl })\r\n        )\r\n      );\r\n\r\n      console.log('Все аватарки обновлены на сервере');\r\n      \r\n    } catch (error) {\r\n      console.error('Ошибка при массовом обновлении аватаров на сервере:', error);\r\n    }\r\n  }\r\n  async updateAvatarInPostsAndComments(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      // Обновляем аватарку во всех постах\r\n      this.posts.forEach(post => {\r\n        if (post.authorId === userId) {\r\n          post.authorAvatarUrl = newAvatarUrl; // Обновляем аватарку в постах\r\n        }\r\n      });\r\n\r\n      // Обновляем аватарку во всех комментариях (не только preview)\r\n      Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\r\n        this.commentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl }; // Обновляем аватарку в комментариях\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      // Обновляем аватарки в preview комментариях\r\n      Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\r\n        this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\r\n          if (comment.authorId === userId) {\r\n            return { ...comment, authorAvatarUrl: newAvatarUrl }; // Обновляем аватарку в preview комментариях\r\n          }\r\n          return comment;\r\n        });\r\n      });\r\n\r\n      // Принудительно обновляем массивы для MobX\r\n      this.posts = [...this.posts];\r\n\r\n      console.log('Аватарки обновлены в постах и комментариях');\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении аватарок в постах и комментариях:', error);\r\n    }\r\n  }\r\n\r\n  async updateAvatarOnServer(userId: ID, newAvatarUrl: string) {\r\n    try {\r\n      const payload = { avatarUrl: newAvatarUrl }\r\n      console.log(`Отправляем запрос на сервер для обновления аватарки пользователя ${userId}`);\r\n      const response = await http.patch(`/users/${userId}`, payload);\r\n      console.log('Ответ от сервера при обновлении аватарки:', response);\r\n\r\n      // Обновляем аватарки во всех связанных данных на сервере\r\n      await this.updateAllUserAvatarsOnServer(userId, newAvatarUrl);\r\n      \r\n      // И только потом обновляем на клиенте\r\n      await this.updateAvatarInPostsAndComments(userId, newAvatarUrl);\r\n    } catch (error) {\r\n      console.error('Ошибка при обновлении аватарки на сервере:', error);\r\n    }\r\n  }\r\n\r\n  async refreshAvatarInCache(userId: ID, newAvatarUrl: string) {\r\n    runInAction(() => {\r\n      // Проверяем, действительно ли нужно обновлять\r\n      const currentAvatar = this.posts.find(p => p.authorId === userId)?.authorAvatarUrl;\r\n      if (currentAvatar === newAvatarUrl) {\r\n        console.log('Аватар уже актуален, пропускаем обновление');\r\n        return;\r\n      }\r\n\r\n      console.log('Обновление аватарки для пользователя:', userId, 'новая ссылка:', newAvatarUrl);\r\n\r\n          // 1. Обновляем аватарку в постах\r\n          this.posts.forEach(post => {\r\n              if (post.authorId === userId) {\r\n                  console.log(`Обновляем аватарку в посте ${post.id}`);\r\n                  post.authorAvatarUrl = newAvatarUrl;\r\n              }\r\n          });\r\n\r\n          // 2. Обновляем аватарку в комментариях\r\n          Object.entries(this.commentsByPost).forEach(([postId, comments]) => {\r\n              this.commentsByPost[Number(postId)] = comments.map(comment => {\r\n                  if (comment.authorId === userId) {\r\n                      console.log(`Обновляем аватарку в комментарии ${comment.id} поста ${postId}`);\r\n                      return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n                  }\r\n                  return comment;\r\n              });\r\n          });\r\n\r\n          // 3. Обновляем аватарку в preview комментариях\r\n          Object.entries(this.previewCommentsByPost).forEach(([postId, comments]) => {\r\n              this.previewCommentsByPost[Number(postId)] = comments.map(comment => {\r\n                  if (comment.authorId === userId) {\r\n                      console.log(`Обновляем аватарку в preview комментарии ${comment.id} поста ${postId}`);\r\n                      return { ...comment, authorAvatarUrl: newAvatarUrl };\r\n                  }\r\n                  return comment;\r\n              });\r\n          });\r\n\r\n          // 4. Принудительно обновляем массивы для MobX\r\n          this.posts = [...this.posts];\r\n\r\n          console.log('Аватарки обновлены');\r\n      });\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}